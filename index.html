<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"kqnonrime.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"manual",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="轻推门扉，至见花影"><meta property="og:type" content="website"><meta property="og:title" content="群青学院"><meta property="og:url" content="https://kqnonrime.github.io/index.html"><meta property="og:site_name" content="群青学院"><meta property="og:description" content="轻推门扉，至见花影"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Kqnonrime"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://kqnonrime.github.io/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>群青学院</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">群青学院</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/7474.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/posts/7474.html" class="post-title-link" itemprop="url">STM32入门</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-22 20:52:05 / 修改时间：21:33:11" itemprop="dateCreated datePublished" datetime="2023-01-22T20:52:05+08:00">2023-01-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">-note</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="STM32工程建立"><a href="#STM32工程建立" class="headerlink" title="STM32工程建立"></a>STM32工程建立</h1><img src="2023-01-22-21-25-28-image.png" alt="" data-align="center"><p><img src="/../images/STM32%E5%85%A5%E9%97%A8/2023-01-22-21-26-34-image.png"></p><p><img src="/../images/STM32%E5%85%A5%E9%97%A8/2023-01-22-21-27-26-image.png"></p><p><img src="/../images/STM32%E5%85%A5%E9%97%A8/2023-01-22-21-27-45-image.png"></p><p><img src="/../images/STM32%E5%85%A5%E9%97%A8/2023-01-22-21-28-48-image.png"></p><p>安装MDK Keil5和STM32F10x器件库</p><p>官网下载外设固件库<strong>STM32F10x_StdPeriph_Lib_V3.5.0</strong></p><p>添加工程必要文件 Libraries-&gt;CMSIS -&gt; CM3-&gt; DeviceSupport-&gt; ST-&gt; STM32F10x-&gt; startup-&gt; arm-&gt;<strong>启动文件</strong>，复制到工程模板（新建Start）</p><p>回到STM32F10x（复制三个文件<strong>stmxxxh、systemxxx.c、systemxxx.h</strong>）复制到<strong>Start</strong></p><p>打开CM3-&gt;CoreSupport(将两个文件复制到Start)</p><p>添加宏定义<strong>USE_STDPERIPH_DRIVER</strong></p><p>回到Keil将文件添加到工程-&gt;点击Target1,将Source Group1单击改名Start-&gt;右键选择添加已存在文件，打开Start文件夹，打开筛选器All files,添加启动文件（<strong>STM32F103C8</strong>型号后缀为<strong>md.s</strong>）和剩下所有.c.h文件-&gt;在工程选项添加该文件夹头文件路径（魔术棒按钮，C&#x2F;C++,Include Paths栏点右边三个点按钮新建路径再点右三个点按钮添加Start路径，最后点ok）</p><p>宏定义STM32F10X_HD 容量选择如下：LD 16-32KB，MD 64-128KB，HD 256-512KB</p><p><img src="/../images/STM32%E5%85%A5%E9%97%A8/2023-01-22-21-28-13-image.png"></p><p>打开新建工程文件夹，添加新文件夹<strong>User</strong>（放main函数），keil里Target右键新建（组别）改名User添加文件选.c名叫main，在main里右键插入头文件stm32f10x.h(若用寄存器开发32，到此就完成工程建立)<br>扳手里Encoding-&gt;<strong>UTF-8</strong>可以防止中文乱码</p><p>在工程文件夹中新建<strong>Libray</strong>文件夹，keil里Target右键新建组别Libray，将Libraries-&gt;STM32F10x_StdPeriph_Driver中所有文件（所有.c.h文件）复制到Libray文件夹并在Keil中添加此目录中所有文件</p><p>在编辑器Include Paths栏中<strong>添加Start，User和Libray文件路径</strong>(若用库函数开发32，到此就完成工程建立)</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/9323.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/posts/9323.html" class="post-title-link" itemprop="url">C++ Basics</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-18 16:40:53" itemprop="dateCreated datePublished" datetime="2022-10-18T16:40:53+08:00">2022-10-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-10-19 12:09:10" itemprop="dateModified" datetime="2022-10-19T12:09:10+08:00">2022-10-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">-note</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>常类型是指使用类型修饰符<strong>const</strong>说明的类型，常类型的变量或对象的值是不能被更新的。</p><h2 id="1-const作用"><a href="#1-const作用" class="headerlink" title="1.const作用"></a>1.const作用</h2><ul><li>可以定义常量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><ul><li><p>类型检查</p><ul><li>const定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。</li><li>其他情况下它只是一个 <code>const</code> 限定的变量，不要将与常量混淆。</li></ul></li><li><p>防止修改，起保护作用，增加程序健壮性</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>&#123;    </span><br><span class="line">    i++; <span class="comment">//error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以节省空间，避免不必要的内存分配</p><ul><li>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像<code>#define</code>一样给出的是立即数。</li><li>const定义的常量在程序运行过程中只有一份拷贝，而<code>#define</code>定义的常量在内存中有若干个拷贝。</li></ul></li></ul><h2 id="2-const对象默认为文件局部变量"><a href="#2-const对象默认为文件局部变量" class="headerlink" title="2.const对象默认为文件局部变量"></a>2.const对象默认为文件局部变量</h2><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><blockquote><p>未被const修饰的变量在不同文件的访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">int</span> ext;</span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(ext+<span class="number">10</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>const常量在不同文件的访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern_file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext=<span class="number">12</span>;</span><br><span class="line"><span class="comment">//extern_file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ext&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结：<br>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p></blockquote><h2 id="3-定义常量"><a href="#3-定义常量" class="headerlink" title="3.定义常量"></a>3.定义常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;b = <span class="number">0</span>; <span class="comment">// error: assignment of read-only variable ‘b’</span></span><br><span class="line"><span class="type">const</span> <span class="built_in">string</span> s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i,j=<span class="number">0</span> <span class="comment">// error: uninitialized const ‘i’</span></span><br></pre></td></tr></table></figure><p>上述有两个错误：</p><ul><li>b 为常量，不可更改！</li><li>i 为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</li></ul><h2 id="4-指针与const"><a href="#4-指针与const" class="headerlink" title="4.指针与const"></a>4.指针与const</h2><p>与指针相关的const有四种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * a; <span class="comment">//指向const对象的指针或者说指向常量的指针。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>小结：</strong><br>如果<em>const</em>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于<code>*</code>的右侧，<em>const</em>就是修饰指针本身，即指针本身是常量。</p></blockquote><p>具体使用如下：</p><p>（1） <strong>指向常量的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;*ptr = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</p><p>除此之外，也不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> * vp = &amp;p;</span><br><span class="line"><span class="type">void</span> *vp = &amp;p; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>另外一个重点是：<strong>允许把非const对象的地址赋给指向const对象的指针</strong>。</p><p>将非const对象的地址赋给const对象的指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">int</span> val = <span class="number">3</span>;ptr = &amp;val; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</p><p>我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr1 = &amp;val;*ptr1=<span class="number">4</span>;<span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>小结：<br>1.对于指向常量的指针，不能通过指针来修改对象的值。<br>2.不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p></blockquote><p>（2） <strong>常指针</strong></p><p>const指针必须进行初始化，且const指针的值不能修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;    </span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//const指针必须初始化！且const指针的值不能修改</span></span><br><span class="line">    <span class="type">int</span> * t = &amp;num;    </span><br><span class="line">    *t = <span class="number">1</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述修改ptr指针所指向的值，可以通过非const指针来修改。</p><p>最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int<code>*</code> -&gt; int <code>*</code>错误！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num=<span class="number">0</span>;    </span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//error! const int* -&gt; int*</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述若改为 const int <code>*</code>ptr或者改为const int <code>*</code>const ptr，都可以正常！</p><p>（3）<strong>指向常量的常指针</strong></p><p>理解完前两种情况，下面这个情况就比较好理解了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> ptr = &amp;p; </span><br></pre></td></tr></table></figure><p>ptr是一个const指针，然后指向了一个int 类型的const对象。</p><h2 id="5-函数中使用const"><a href="#5-函数中使用const" class="headerlink" title="5.函数中使用const"></a>5.函数中使用const</h2><blockquote><p>const修饰函数返回值</p></blockquote><p>这个跟const修饰普通变量以及指针的含义基本相同：</p><p>（1）<strong>const int</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这个本身无意义，因为参数返回本身就是赋值给其他的变量！</p><p>（2）<strong>const int</strong>*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="title function_">func2</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>指针指向的内容不变。</p><p>（3）int *const</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>指针本身不可变。</p><blockquote><p>const修饰函数参数</p></blockquote><p>（1）传递过来的参数及指针本身在函数内不可变，无意义！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span>; <span class="comment">// 传递过来的参数不可变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> var)</span>; <span class="comment">// 指针本身不可变</span></span><br></pre></td></tr></table></figure><p>表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</p><p>输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</p><p>（2）<strong>参数指针所指内容为常量不可变</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p><p>（3）<strong>参数为引用，为了增加效率同时防止修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span><br></pre></td></tr></table></figure><p>对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p><p>为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。</p><blockquote><p>但是函数void func(A &amp;a) 存在一个缺点：</p><p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p></blockquote><p>以此类推，是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p><blockquote><p>小结：<br>1.对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。</p><p>2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</p></blockquote><p>以上解决了两个面试问题：</p><ul><li>如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；</li><li>如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。</li></ul><h2 id="6-类中使用const"><a href="#6-类中使用const" class="headerlink" title="6.类中使用const"></a>6.类中使用const</h2><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。</p><p>对于类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line">public:</span><br><span class="line">    Apple(<span class="type">int</span> i);     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::Apple(<span class="type">int</span> i):apple_number(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apple.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line">public:</span><br><span class="line">    Apple(<span class="type">int</span> i);     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apple.cpp&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Apple::Apple(<span class="type">int</span> i):apple_number(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Apple::add</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    take(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Apple::add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span><br><span class="line">&#123;    </span><br><span class="line">    take(num);    </span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Apple::take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;take func &quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Apple::getCount</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;    </span><br><span class="line">    take(<span class="number">1</span>);    </span><br><span class="line">    add();  <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> apple_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    Apple <span class="title function_">a</span><span class="params">(<span class="number">2</span>)</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.getCount()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    a.add(<span class="number">10</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译： g++ -o main main.cpp apple.cpp</p></blockquote><p>此时报错，上面getCount()方法中调用了一个add方法，而add方法并非const修饰，所以运行报错。也就是说const成员函数只能访问const成员函数。</p><p>当调用改为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Apple <span class="title">b</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">b.<span class="keyword">add</span>(); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>此时，可以证明的是const对象只能访问const成员函数。</p><p>我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：</p><p>第一：将常量定义与static结合，也就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number</span><br></pre></td></tr></table></figure><p>第二：在外面初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>当然，如果你使用c++11进行编译，直接可以在定义处初始化，可以直接写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这两种都在c++11中支持！</p><p>编译的时候加上<code>-std=c++11</code>即可！</p><p>这里提到了static，下面简单的说一下：</p><p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</p><p>在类中声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> ap;</span><br></pre></td></tr></table></figure><p>在类实现文件中使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Apple::ap=<span class="number">666</span></span><br></pre></td></tr></table></figure><p>对于此项，c++11不能进行声明并初始化，也就是上述使用方法。</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>当与不同类型一起使用时，Static关键字具有不同的含义：</p><p><strong>静态变量：</strong> 函数中的变量，类中的变量</p><p><strong>静态类的成员：</strong> 类对象和类中的函数</p><p><strong>静态变量</strong></p><ul><li>函数中的静态变量</li></ul><p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">()</span> </span><br><span class="line">&#123;     <span class="comment">// static variable </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;         <span class="comment">// value is updated and </span></span><br><span class="line">    <span class="comment">// will be carried to next </span></span><br><span class="line">    <span class="comment">// function calls </span></span><br><span class="line">    count++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;     </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)             </span><br><span class="line">    demo();     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><ul><li>类中的静态变量</li></ul><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public:     </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;         </span><br><span class="line">    Apple()     </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    Apple obj1; </span><br><span class="line">    Apple obj2; </span><br><span class="line">    obj1.i = <span class="number">2</span>; </span><br><span class="line">    obj2.i = <span class="number">3</span>;     </span><br><span class="line">    <span class="comment">// prints value of i </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj1.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;obj2.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>您可以在上面的程序中看到我们已经尝试为多个对象创建静态变量i的多个副本。但这并没有发生。因此，类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public:     </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;         </span><br><span class="line">    Apple()     </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="comment">// Do nothing    </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;     </span><br><span class="line">    Apple obj;     <span class="comment">// prints value of i </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>静态成员</strong></p><ul><li>类对象为静态</li></ul><p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p><ul><li>类中的静态函数</li></ul><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>this指针的用处：</p><p>（1）一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p><p>（2）this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p><p>this指针的使用：</p><p>（1）在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</p><p>（2）当参数与成员变量名相同时，如this-&gt;n &#x3D; n （不能写成n &#x3D; n)。</p><p>现有如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>        </span><br><span class="line">    BOY = <span class="number">0</span>,         </span><br><span class="line">    GIRL     </span><br><span class="line">&#125;SexType;    </span><br><span class="line">Person(<span class="type">char</span> *n, <span class="type">int</span> a,SexType s)</span><br><span class="line">&#123;        </span><br><span class="line">    name=new <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>];        </span><br><span class="line">    <span class="built_in">strcpy</span>(name,n);        </span><br><span class="line">    age=a;        </span><br><span class="line">    sex=s;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="type">int</span> <span class="title function_">get_age</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;            </span><br><span class="line">    <span class="keyword">return</span> this-&gt;age;     </span><br><span class="line">&#125;    </span><br><span class="line">Person&amp; <span class="title function_">add_age</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;        </span><br><span class="line">    age+=a;        </span><br><span class="line">    <span class="keyword">return</span> *this;     </span><br><span class="line">&#125;    </span><br><span class="line">~Person()</span><br><span class="line">&#123;        </span><br><span class="line">    delete [] name;    </span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">char</span> * name;    </span><br><span class="line">    <span class="type">int</span> age;    </span><br><span class="line">    SexType sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    Person <span class="title function_">p</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>,Person::BOY)</span>;     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.get_age()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.add_age(<span class="number">10</span>).get_age()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：this在成员函数的开始执行前构造，在成员的执行结束后清除。上述的get_age函数会被解析成<code>get_age(const A * const this)</code>,<code>add_age</code>函数会被解析成<code>add_age(A* const this,int a)</code>。在C++中类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了。</p><h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><ul><li><p>如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收货会更少！</p></li><li><p>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p></li></ul><p>以下情况不宜用内联：</p><p>（1）如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</p><p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><p>对于虚函数：</p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><ul><li>空类的大小为1字节</li><li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li><li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</li><li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li><li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li><li>虚继承,继承基类的vptr。</li></ul><h2 id="1-原则1"><a href="#1-原则1" class="headerlink" title="1.原则1"></a>1.原则1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file blackclass.cpp</span></span><br><span class="line"><span class="comment"> * @brief 空类的大小为1字节</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-原则2"><a href="#2-原则2" class="headerlink" title="2.原则2"></a>2.原则2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file static.cpp</span></span><br><span class="line"><span class="comment"> * @brief 静态数据成员</span></span><br><span class="line"><span class="comment"> * 静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。 </span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    public:</span><br><span class="line">        <span class="type">char</span> b;        </span><br><span class="line">        virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;&#125;;        </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c;        </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> d;        </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 16  字节对齐、静态变量不影响类的大小、vptr指针=8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-原则3"><a href="#3-原则3" class="headerlink" title="3.原则3"></a>3.原则3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file morevir.cpp</span></span><br><span class="line"><span class="comment"> * @brief 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span>;    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span>;    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-原则4与5"><a href="#4-原则4与5" class="headerlink" title="4.原则4与5"></a>4.原则4与5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file geninhe.cpp</span></span><br><span class="line"><span class="comment"> * @brief 1.普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)</span></span><br><span class="line"><span class="comment"> * 注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。</span></span><br><span class="line"><span class="comment"> * 2.虚单继承，派生类继承基类vptr</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    public:</span><br><span class="line">        <span class="type">char</span> a;        <span class="type">int</span> b;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 此时B按照顺序：</span></span><br><span class="line"><span class="comment"> * char a</span></span><br><span class="line"><span class="comment"> * int b</span></span><br><span class="line"><span class="comment"> * short a</span></span><br><span class="line"><span class="comment"> * long b</span></span><br><span class="line"><span class="comment"> * 根据字节对齐4+4+8+8=24</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 或编译器优化</span></span><br><span class="line"><span class="comment"> * char a</span></span><br><span class="line"><span class="comment"> * short a</span></span><br><span class="line"><span class="comment"> * int b</span></span><br><span class="line"><span class="comment"> * long b</span></span><br><span class="line"><span class="comment"> * 根据字节对齐2+2+4+8=16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>A&#123;    public:</span><br><span class="line">        <span class="type">short</span> a;        <span class="type">long</span> b;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把A的成员拆开看，char为1，int为4，所以是1+（3）+4+1+（3）=12，（）为字节补齐</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span>    A a;    <span class="type">char</span> c;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span></span></span><br><span class="line"><span class="class">&#123;</span>    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>:</span>public A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16 或 24</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 对于虚单函数继承，派生类也继承了基类的vptr，所以是8字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C1)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-原则6"><a href="#5-原则6" class="headerlink" title="5.原则6"></a>5.原则6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file virnhe.cpp</span></span><br><span class="line"><span class="comment"> * @brief 虚继承</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> virtual public  A, virtual public B</span><br><span class="line">&#123;    </span><br><span class="line">    public:</span><br><span class="line">        virtual <span class="type">void</span> <span class="title function_">fun3</span><span class="params">()</span> </span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 8 8 16  派生类虚继承多个虚函数，会继承所有虚函数的vptr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(C);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><h2 id="1-纯虚函数与抽象类"><a href="#1-纯虚函数与抽象类" class="headerlink" title="1.纯虚函数与抽象类"></a>1.纯虚函数与抽象类</h2><p>C++中的纯虚函数(或抽象函数)是没有实现的虚函数！只需声明它! 通过声明中赋值0来声明纯虚函数！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line">Class A &#123;</span><br><span class="line">public:     </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> = <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="comment">/* Other members */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>纯虚函数：没有函数体的虚函数</li><li>抽象类：包含纯虚函数的类</li></ul><p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象,抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</p><h2 id="2-实现抽象类"><a href="#2-实现抽象类" class="headerlink" title="2.实现抽象类"></a>2.实现抽象类</h2><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数&#x2F;析构函数内部不能使用纯虚函数。</p><p>如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A为抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> = <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">g</span><span class="params">()</span>&#123; this-&gt;f(); &#125;    </span><br><span class="line">    A()&#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B:f()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  <span class="comment">// 实现了抽象类的纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-重要点"><a href="#3-重要点" class="headerlink" title="3.重要点"></a>3.重要点</h2><ul><li>纯虚函数使一个类变成抽象类</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">public:     </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> = <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 普通成员函数</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">     <span class="type">int</span> x; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>抽象类类型的指针和引用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123; </span><br><span class="line">public:     </span><br><span class="line">    <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In Derived \n&quot;</span>; &#125; <span class="comment">// 实现抽象类的纯虚函数</span></span><br><span class="line">    Derived()&#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;     </span><br><span class="line">    <span class="comment">//Base b;  // error! 不能创建抽象类的对象</span></span><br><span class="line">    <span class="comment">//Base *b = new Base(); error!</span></span><br><span class="line"></span><br><span class="line">    Base *bp = new Derived(); <span class="comment">// 抽象类的指针和引用 -&gt; 由抽象类派生出来的类的对象</span></span><br><span class="line">    bp-&gt;show();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Derived为抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base &#123; </span><br><span class="line">public: </span><br><span class="line"><span class="comment">//    void show() &#123;&#125;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>抽象类可以有构造函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>     </span><br><span class="line">protected:         </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">public:         </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> = <span class="number">0</span>;         </span><br><span class="line">    Base(<span class="type">int</span> i) &#123; x = i; &#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base &#123;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">public:     </span><br><span class="line">    Derived(<span class="type">int</span> i, <span class="type">int</span> j) : Base(i) &#123; y = j; &#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>构造函数不能是虚函数，而析构函数可以是虚析构函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Base()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor: Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;    </span><br><span class="line">    virtual ~Base()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor : Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;        </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor: Derived&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;    </span><br><span class="line">    ~Derived()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor : Derived&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;        </span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In Derived.func().&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。 如果析构函数不是虚拟的，则只能调用基类析构函数。</p></blockquote><h1 id="C-虚函数的vptr与vtable"><a href="#C-虚函数的vptr与vtable" class="headerlink" title="C++虚函数的vptr与vtable"></a>C++虚函数的vptr与vtable</h1><p>为了实现虚函数，C ++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态&#x2F;后期绑定方式的函数调用函数的查找表。虚拟表有时会使用其他名称，例如“vtable”，“虚函数表”，“虚方法表”或“调度表”。</p><p>虚拟表实际上非常简单，虽然用文字描述有点复杂。首先，<strong>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表</strong>。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p><p>其次，编译器还会添加一个隐藏指向基类的指针，我们称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p><p>因此，它使每个类对象的分配大一个指针的大小。这也意味着vptr由派生类继承，这很重要。</p><h1 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h1><p><strong>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。</strong></p><p><strong>默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型</strong>。</p><p>（1） <strong>静态函数可以声明为虚函数吗？</strong></p><p>原因主要有两方面：</p><p><strong>静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰</strong></p><p>static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义</p><p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。</p><p>（2）<strong>构造函数可以为虚函数吗？</strong></p><p>构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。</p><p>为什么构造函数不可以为虚函数？</p><p>尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。</p><p>我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。 因此，构造函数没有必要被声明为虚函数。</p><p>（3）<strong>析构函数可以为虚函数吗？</strong></p><p><strong>析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。</strong></p><p>（4）<strong>虚函数可以为私有函数吗？</strong></p><ul><li>基类指针指向继承类对象，则调用继承类对象的函数；</li><li>int main()必须声明为Base类的友元，否则编译失败。 编译器报错： ptr无法访问私有函数。 当然，把基类声明为public， 继承类为private，该问题就不存在了。</li></ul><p>（5）<strong>虚函数可以被内联吗？</strong></p><p><strong>通常类成员函数都会被编译器考虑是否进行内联。 但通过基类指针或者引用调用的虚函数必定不能被内联。 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。</strong></p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%BA%E7%B1%BB/9589663">基类</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>或引用来检查这些指针或引用所指的对象的实际<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B4%BE%E7%94%9F%E7%B1%BB">派生类</a>型。</p><p>在面向对象程序设计中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof，以及C#的as、is运算符类似，C++提供了dynamic_cast函数用于动态转型。相比C风格的强制类型转换和C++ reinterpret_cast，dynamic_cast提供了类型安全检查，是一种基于能力查询(Capability Query)的转换，所以在多态类型间进行转换更提倡采用dynamic_cast。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p><h2 id="volatile应用"><a href="#volatile应用" class="headerlink" title="volatile应用"></a>volatile应用</h2><p>（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *output = (<span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>; <span class="comment">//定义一个IO端口；  </span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;      </span><br><span class="line">    <span class="type">int</span> i;      </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)    </span><br><span class="line">    &#123;      </span><br><span class="line">        *output = i;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;      </span><br><span class="line">    *output = <span class="number">9</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p><p>（2）一个中断服务子程序中访问到的变量；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(i) dosomething();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt service routine */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IRS</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。</p><p>（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">bool</span> bStop=<span class="literal">false</span>;  <span class="comment">//bStop 为共享全局变量  </span></span><br><span class="line"><span class="comment">//第一个线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadFunc1</span><span class="params">()</span>&#123;    ...    <span class="keyword">while</span>(!bStop)&#123;...&#125;&#125;</span><br><span class="line"><span class="comment">//第二个线程终止上面的线程循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadFunc2</span><span class="params">()</span>&#123;    ...    bStop = <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure><p>要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p><p>是否了解volatile的应用场景是区分C&#x2F;C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。</p><h2 id="volatile使用"><a href="#volatile使用" class="headerlink" title="volatile使用"></a>volatile使用</h2><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p></li></ul><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>断言，<strong>是宏，而非函数</strong>。</p><p>assert 宏的原型定义在 &lt;assert.h&gt;（C）、（C++）中。其作用是如果它的条件返回错误，则终止程序执行。</p><p>可以通过定义 <code>NDEBUG</code> 来关闭 assert，<strong>但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">(<span class="type">int</span> expression)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x = <span class="number">7</span>;     <span class="comment">/*  Some big code in between and let&#x27;s say x  </span></span><br><span class="line"><span class="comment">    is accidentally changed to 9  */</span></span><br><span class="line">    x = <span class="number">9</span>;     <span class="comment">// Programmer assumes x to be 7 in rest of the code </span></span><br><span class="line">    assert(x==<span class="number">7</span>);     <span class="comment">/* Rest of the code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert: assert.c:<span class="number">13</span>: main: Assertion <span class="string">&#x27;x==7&#x27;</span> failed.</span><br></pre></td></tr></table></figure><p>可以看到输出会把源码文件，行号错误位置，提示出来！</p><ul><li>断言主要用于检查逻辑上不可能的情况。</li></ul><blockquote><p>例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。</p></blockquote><ul><li>忽略断言，在代码开头加上：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br></pre></td></tr></table></figure><h1 id="Bit-field"><a href="#Bit-field" class="headerlink" title="Bit field"></a>Bit field</h1><p>“ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。这种数据结构的一个好处是它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。第二个好处是位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。而这种数据结构的缺点在于，位段实现依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h2 id="位域使用"><a href="#位域使用" class="headerlink" title="位域使用"></a>位域使用</h2><p>位域通常使用结构体声明， 该结构声明为每个位域成员设置名称，并决定其宽度：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">bit_field_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">member_name</span> <span class="operator">:</span> width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Elements</th><th>Description</th></tr></thead><tbody><tr><td>bit_field_name</td><td>位域结构名</td></tr><tr><td>type</td><td>位域成员的类型，必须为 int、signed int 或者 unsigned int 类型</td></tr><tr><td>member_name</td><td>位域成员名</td></tr><tr><td>width</td><td>规定成员所占的位数</td></tr></tbody></table><p>例如声明如下一个位域:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_PRCODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> code1: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cdde2: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> code3: <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PRCODE</span> prcode;</span><br></pre></td></tr></table></figure><p>该定义使 <code>prcode</code>包含 2 个 2 Bits 位域和 1 个 8 Bits 位域，我们可以使用结构体的成员运算符对其进行赋值</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">prcode.code1</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">prcode.code2</span> = <span class="number">3</span><span class="comment">;</span></span><br><span class="line"><span class="attr">procde.code3</span> = <span class="number">102</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>赋值时要注意值的大小不能超过位域成员的容量，例如 prcode.code3 为 8 Bits 的位域成员，其容量为 2^8 &#x3D; 256，即赋值范围应为 [0,255]。</p><h2 id="位域的大小和对齐"><a href="#位域的大小和对齐" class="headerlink" title="位域的大小和对齐"></a>位域的大小和对齐</h2><h3 id="位域的大小"><a href="#位域的大小" class="headerlink" title="位域的大小"></a>位域的大小</h3><p>例如以下位域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该位域结构体中间有一个未命名的位域，占据 3 Bits，仅起填充作用，并无实际意义。 填充使得该结构总共使用了 8 Bits。但 C 语言使用 unsigned int 作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同。 有些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。文章以下均默认 unsigned int 为 32 Bits。</p><h3 id="位域的对齐"><a href="#位域的对齐" class="headerlink" title="位域的对齐"></a>位域的对齐</h3><p>一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field1: <span class="number">30</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field2: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field3: <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>field1</code> + <code>field2</code> &#x3D; 34 Bits，超出 32 Bits, 编译器会将<code>field2</code>移位至下一个 unsigned int 单元存放， stuff.field1 和 stuff.field2 之间会留下一个 2 Bits 的空隙， stuff.field3 紧跟在 stuff.field2 之后，该结构现在大小为 2 * 32 &#x3D; 64 Bits。</p><p>这个空洞可以用之前提到的未命名的位域成员填充，我们也可以使用一个宽度为 0 的未命名位域成员令下一位域成员与下一个整数对齐。 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field1: <span class="number">30</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field2: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field3: <span class="number">3</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 stuff.field1 与 stuff.field2 之间有一个 2 Bits 的空隙，stuff.field3 则存储在下一个 unsigned int 中，该结构现在大小为 3 * 32 &#x3D; 96 Bits。</p><h2 id="位域的初始化和位的重映射"><a href="#位域的初始化和位的重映射" class="headerlink" title="位域的初始化和位的重映射"></a>位域的初始化和位的重映射</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>位域的初始化与普通结构体初始化的方法相同，这里列举两种，如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> stuff s1= &#123;<span class="number">20</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>或者直接为位域成员赋值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct stuff s1<span class="comment">;</span></span><br><span class="line">s1.field1 <span class="operator">=</span> <span class="number">20</span><span class="comment">;</span></span><br><span class="line">s1.field2 <span class="operator">=</span> <span class="number">8</span><span class="comment">;</span></span><br><span class="line">s1.field3 <span class="operator">=</span> <span class="number">4</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="位域的重映射-Re-mapping"><a href="#位域的重映射-Re-mapping" class="headerlink" title="位域的重映射 (Re-mapping)"></a>位域的重映射 (Re-mapping)</h3><p>声明一个 大小为 32 Bits 的位域</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ready:     <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> error:     <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> command:   <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sector_no: <span class="number">24</span>;</span><br><span class="line">&#125;b1;</span><br></pre></td></tr></table></figure><h4 id="利用重映射将位域归零"><a href="#利用重映射将位域归零" class="headerlink" title="利用重映射将位域归零"></a>利用重映射将位域归零</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* p = (int *) &amp;b1;  <span class="regexp">//</span> 将 <span class="string">&quot;位域结构体的地址&quot;</span> 映射至 <span class="string">&quot;整形（int*) 的地址&quot;</span> </span><br><span class="line">*p = <span class="number">0</span>;                <span class="regexp">//</span> 清除 s1，将各成员归零</span><br></pre></td></tr></table></figure><h4 id="利用联合-union-将-32-Bits-位域-重映射至-unsigned-int-型"><a href="#利用联合-union-将-32-Bits-位域-重映射至-unsigned-int-型" class="headerlink" title="利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型"></a>利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型</h4><p>先简单介绍一下联合</p><blockquote><p>“联合” 是一种特殊的类，也是一种构造类型的数据结构。在一个 “联合” 内可以定义多种不同的数据类型， 一个被说明为该 “联合” 类型的变量中，允许装入该 “联合” 所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的</p><p>“联合” 与 “结构” 有一些相似之处。但两者有本质上的不同。在结构中各成员有各自的内存空间， 一个结构变量的总长度是各成员长度之和（空结构除外，同时不考虑边界调整）。而在 “联合” 中，各成员共享一段内存空间， 一个联合变量的长度等于各成员中最长的长度。应该说明的是， 这里所谓的共享不是指把多个成员同时装入一个联合变量内， 而是指该联合变量可被赋予任一成员值，但每次只能赋一种值， 赋入新值则冲去旧值。</p></blockquote><p>我们可以声明以下联合:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">u_box</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">box</span> st_box;     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ui_box;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>x86 系统中 unsigned int 和 box 都为 32 Bits, 通过该联合使 st_box 和 ui_box 共享一块内存。具体位域中哪一位与 unsigned int 哪一位相对应，取决于编译器和硬件。 利用联合将位域归零，代码如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union u_box u<span class="comment">;</span></span><br><span class="line">u.ui_box <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><h2 id="1-C-与C编译区别"><a href="#1-C-与C编译区别" class="headerlink" title="1.C++与C编译区别"></a>1.C++与C编译区别</h2><p>在C++中常在头文件见到extern “C”修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。</p><p>C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。</p><p>例如<code>int add(int a, int b)</code>函数经过C++编译器生成.o文件后，<code>add</code>会变成形如<code>add_int_int</code>之类的, 而C的话则会是形如<code>_add</code>, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。</p><p>这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时<code>extern &quot;C&quot;</code>就起作用了：告诉链接器去寻找<code>_add</code>这类的C语言符号，而不是经过C++修饰的符号。</p><h2 id="2-C-调用C函数"><a href="#2-C-调用C函数" class="headerlink" title="2.C++调用C函数"></a>2.C++调用C函数</h2><p>C++调用C函数的例子: 引用C的头文件时，需要加<code>extern &quot;C&quot;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;    <span class="keyword">return</span> x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Generate <span class="keyword">add</span>.o file</span><br><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>链接：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="keyword">add</span>.cpp <span class="keyword">add</span>.o -o main</span><br></pre></td></tr></table></figure><p>没有添加extern “C” 报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; g++ add.cpp add.o -o main                                   add.o：在函数‘main’中：add.cpp:(.text+<span class="number">0x0</span>): `main<span class="number">&#x27;</span>被多次定义</span><br><span class="line">/tmp/ccH65yQF.o:add.cpp:(.text+<span class="number">0x0</span>)：第一次在此定义</span><br><span class="line">/tmp/ccH65yQF.o：在函数‘main’中：</span><br><span class="line">add.cpp:(.text+<span class="number">0xf</span>)：对‘add(<span class="type">int</span>, <span class="type">int</span>)’未定义的引用</span><br><span class="line">add.o：在函数‘main’中：</span><br><span class="line">add.cpp:(.text+<span class="number">0xf</span>)：对‘add(<span class="type">int</span>, <span class="type">int</span>)’未定义的引用</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><p>添加extern “C”后：</p><p><code>add.cpp</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候一定要注意，先通过gcc生成中间文件add.o。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span> </span><br></pre></td></tr></table></figure><p>然后编译：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="keyword">add</span>.cpp <span class="keyword">add</span>.o -o main</span><br></pre></td></tr></table></figure><p>而通常为了C代码能够通用，即既能被C调用，又能被C++调用，头文件通常会有如下写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>即在C++调用该接口时，会以C接口的方式调用。这种方式使得C++者不需要额外的extern C，而标准库头文件通常也是类似的做法，否则你为何不需要extern C就可以直接使用stdio.h中的C函数呢？</p><h2 id="3-C中调用C-函数"><a href="#3-C中调用C-函数" class="headerlink" title="3.C中调用C++函数"></a>3.C中调用C++函数</h2><p><code>extern &quot;C&quot;</code>在C中是语法错误，需要放在C++头文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;    <span class="keyword">return</span> x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c add.cpp</span><br></pre></td></tr></table></figure><p>链接：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">add</span>.<span class="keyword">c</span> <span class="keyword">add</span>.o -o main</span><br></pre></td></tr></table></figure><p>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p><p>总结出如下形式：</p><p>（1）C++调用C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）C调用C++函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;    &#125;</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>不过与C++调用C接口不同，C++确实是能够调用编译好的C函数，而这里C调用C++，不过是把C++代码当成C代码编译后调用而已。也就是说，C并不能直接调用C++库函数。</p><h1 id="C和C-中struct"><a href="#C和C-中struct" class="headerlink" title="C和C++中struct"></a>C和C++中struct</h1><h2 id="1-C中struct"><a href="#1-C中struct" class="headerlink" title="1.C中struct"></a>1.C中struct</h2><ul><li>在C中struct只单纯的用作数据的复合类型，也就是说，在结构体声明中只能将数据成员放在里面，而不能将函数放在里面。</li><li>在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用。</li><li>在C中定义结构体变量，如果使用了下面定义必须加struct。</li><li>C的结构体不能继承（没有这一概念）。</li><li>若结构体的名字与函数名相同，可以正常运行且正常的调用！例如：可以定义与 struct Base 不冲突的 void Base() {}。</li></ul><p>完整案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>            <span class="comment">// public</span></span><br><span class="line">    <span class="type">int</span> v1; </span><br><span class="line"><span class="comment">//    public:      //error</span></span><br><span class="line">        <span class="type">int</span> v2;     <span class="comment">//private:</span></span><br><span class="line">        <span class="type">int</span> v3;     <span class="comment">//void print()&#123;       // c中不能在结构体中嵌入函数</span></span><br><span class="line">    <span class="comment">//    printf(&quot;%s\n&quot;,&quot;hello world&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;;    //error!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Base</span><span class="params">()</span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;I am Base func&quot;</span>);&#125;</span><br><span class="line"><span class="comment">//struct Base base1;  //ok</span></span><br><span class="line"><span class="comment">//Base base2; //error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">base</span>;</span>    </span><br><span class="line">    base.v1=<span class="number">1</span>;    <span class="comment">//base.print();</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v1);    </span><br><span class="line">    Base();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">I am Base <span class="keyword">func</span></span><br></pre></td></tr></table></figure><h2 id="2-C-中struct"><a href="#2-C-中struct" class="headerlink" title="2.C++中struct"></a>2.C++中struct</h2><p>与C对比如下：</p><ul><li>C++结构体中不仅可以定义数据，还可以定义函数。</li><li>C++结构体中可以使用访问修饰符，如：public、protected、private 。</li><li>C++结构体使用可以直接使用不带struct。</li><li>C++继承</li><li>若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只能用带struct的！</li></ul><p>例如：</p><blockquote><p>情形1：不适用typedef定义结构体别名</p></blockquote><p>未添加同名函数前：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>    &#125;;</span><br><span class="line"><span class="comment">//Student()&#123;&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span> <span class="comment">//ok</span></span><br><span class="line">Student s;  <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>添加同名函数后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>    &#125;;</span><br><span class="line">Student()&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span> <span class="comment">//ok</span></span><br><span class="line">Student s;  <span class="comment">//error</span></span><br></pre></td></tr></table></figure><blockquote><p>情形二：使用typedef定义结构体别名</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> </span></span><br><span class="line"><span class="class">&#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;    </span><br><span class="line">    <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">    <span class="type">int</span> v2;    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>); &#125;;    </span><br><span class="line">&#125;B;</span><br><span class="line"><span class="comment">//void B() &#123;&#125;  //error! 符号 &quot;B&quot; 已经被定义为一个 &quot;struct Base1&quot; 的别名</span></span><br></pre></td></tr></table></figure><blockquote><p>前三种案例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;    </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);   &#125;;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">base1</span>;</span>  <span class="comment">//ok</span></span><br><span class="line">    Base base2; <span class="comment">//ok</span></span><br><span class="line">    Base base;    </span><br><span class="line">    base.v1=<span class="number">1</span>;    </span><br><span class="line">    base.v3=<span class="number">2</span>;    </span><br><span class="line">    base.print();    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v1);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v3);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承案例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:   <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;    </span><br><span class="line">        virtual <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Base&quot;</span>);  &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span>Base &#123;             </span><br><span class="line">public:</span><br><span class="line">        <span class="type">int</span> v2;    </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Derived&quot;</span>);  &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    Base *b=new Derived();    </span><br><span class="line">    b-&gt;print();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同名函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;   </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);  &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span>             </span><br><span class="line">        <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;   </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);   &#125;;    </span><br><span class="line">&#125;B;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Base</span><span class="params">()</span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;I am Base func&quot;</span>);&#125;</span><br><span class="line"><span class="comment">//void B() &#123;&#125;  //error! 符号 &quot;B&quot; 已经被定义为一个 &quot;struct Base1&quot; 的别名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">base</span>;</span>  <span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//Base base1;  // error!</span></span><br><span class="line">    base.v1=<span class="number">1</span>;    </span><br><span class="line">    base.v3=<span class="number">2</span>;    </span><br><span class="line">    base.print();    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v1);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v3);    </span><br><span class="line">    Base();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><h3 id="C和C-中的Struct区别"><a href="#C和C-中的Struct区别" class="headerlink" title="C和C++中的Struct区别"></a>C和C++中的Struct区别</h3><table><thead><tr><th>C</th><th>C++</th></tr></thead><tbody><tr><td>不能将函数放在结构体声明</td><td>能将函数放在结构体声明</td></tr><tr><td>在C结构体声明中不能使用C++访问修饰符。</td><td>public、protected、private 在C++中可以使用。</td></tr><tr><td>在C中定义结构体变量，如果使用了下面定义必须加struct。</td><td>可以不加struct</td></tr><tr><td>结构体不能继承（没有这一概念）。</td><td>可以继承</td></tr><tr><td>若结构体的名字与函数名相同，可以正常运行且正常的调用！</td><td>若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！</td></tr></tbody></table><h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><h1 id="C实现C-的面向对象特性"><a href="#C实现C-的面向对象特性" class="headerlink" title="C实现C++的面向对象特性"></a>C实现C++的面向对象特性</h1><p>C++中的多态:在C++中会维护一张虚函数表，根据赋值兼容规则，我们知道父类的指针或者引用是可以指向子类对象的。</p><p>如果一个父类的指针或者引用调用父类的虚函数则该父类的指针会在自己的虚函数表中查找自己的函数地址，如果该父类对象的指针或者引用指向的是子类的对象，而且该子类已经重写了父类的虚函数，则该指针会调用子类的已经重写的虚函数。</p><ul><li>封装</li></ul><p>C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟；</p><p>使用函数指针把属性与方法封装到结构体中。</p><ul><li>继承</li></ul><p>结构体嵌套</p><ul><li>多态</li></ul><p>类与子类方法的函数指针不同</p><p>在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。</p><p>模拟多态，必须保持函数指针变量对齐(在内容上完全一致，而且变量对齐上也完全一致)。否则父类指针指向子类对象，运行崩溃！</p><h1 id="explicit-显式-关键字"><a href="#explicit-显式-关键字" class="headerlink" title="explicit(显式)关键字"></a>explicit(显式)关键字</h1><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外</li></ul><h1 id="友元函数与友元类"><a href="#友元函数与友元类" class="headerlink" title="友元函数与友元类"></a>友元函数与友元类</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><p>友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员的机制。也就是说有两种形式的友元：</p><p>（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。</p><p>（2）友元类：类A中的成员函数访问类B中的私有或保护成员</p><p>优点：提高了程序的运行效率。</p><p>缺点：破坏了类的封装性和数据的透明性。</p><p>总结：</p><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h2 id="1-友元函数"><a href="#1-友元函数" class="headerlink" title="1.友元函数"></a>1.友元函数</h2><p>在类声明的任何区域中声明，而定义则在类的外部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend <span class="tag">&lt;<span class="name">类型</span>&gt;</span><span class="tag">&lt;<span class="name">友元函数名</span>&gt;</span>(<span class="tag">&lt;<span class="name">参数表</span>&gt;</span>);</span><br></pre></td></tr></table></figure><p>注意，友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> _a):a(_a)&#123;&#125;;    </span><br><span class="line">    friend <span class="type">int</span> <span class="title function_">geta</span><span class="params">(A &amp;ca)</span>;  <span class="comment">///&lt; 友元函数</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">geta</span><span class="params">(A &amp;ca)</span> &#123;    <span class="keyword">return</span> ca.a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    A <span class="title function_">a</span><span class="params">(<span class="number">3</span>)</span>;        </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;geta(a)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-友元类"><a href="#2-友元类" class="headerlink" title="2.友元类"></a>2.友元类</h2><p>友元类的声明在该类的声明中，而实现在该类外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> &lt;友元类名&gt;;</span><br></pre></td></tr></table></figure><p>类B是类A的友元，那么类B可以直接访问A的私有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> _a):a(_a)&#123;&#125;;    </span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getb</span><span class="params">(A ca)</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span>  ca.a;     </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    A <span class="title function_">a</span><span class="params">(<span class="number">3</span>)</span>;    </span><br><span class="line">    B b;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.getb(a)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h2><ul><li><p>友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。</p></li><li><p>友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。</p></li></ul><h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>局部与全局using，具体操作与使用见下面案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isNs1 1</span></span><br><span class="line"><span class="comment">//#define isGlobal 2</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;::func&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace ns1 &#123;    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ns1::func&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace ns2 </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> isNs1     </span></span><br><span class="line">    using ns1::func;    <span class="comment">/// ns1中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> isGlobal    </span></span><br><span class="line">    using ::func; <span class="comment">/// 全局中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>     </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;other::func&quot;</span>&lt;&lt;<span class="built_in">endl</span>;     </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这就是为什么在c++中使用了cmath而不是math.h头文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ns2::func(); <span class="comment">// 会根据当前环境定义宏的不同来调用不同命名空间下的func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改变访问性"><a href="#改变访问性" class="headerlink" title="改变访问性"></a>改变访问性</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n;  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类Derived私有继承了Base，对于它来说成员变量n和成员函数size都是私有的，如果使用了using语句，可以改变他们的可访问性，如上述例子中，size可以按public的权限访问，n可以按protected的权限访问。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。</p><p>如果对于基类的重载函数，我们需要在派生类中修改一个，又要让其他的保持可见，必须要重载所有版本，这样十分的繁琐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>    </span><br><span class="line">public:</span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;        </span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::f(int)&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> private Base </span><br><span class="line">&#123;    public:</span><br><span class="line">        using Base::f;        </span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Derived::f(int)&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    Base b;    </span><br><span class="line">    Derived d;    </span><br><span class="line">    d.f();    </span><br><span class="line">    d.f(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，在派生类中使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。</p><h2 id="取代typedef"><a href="#取代typedef" class="headerlink" title="取代typedef"></a>取代typedef</h2><p>C中常用typedef A B这样的语法，将B定义为A类型，也就是给A类型一个别名B</p><p>对应typedef A B，使用using B&#x3D;A可以进行同样的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; V1; </span><br><span class="line">using V2 = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul><h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><h2 id="传统行为"><a href="#传统行为" class="headerlink" title="传统行为"></a>传统行为</h2><p>枚举有如下问题：</p><ul><li>作用域不受限,会容易引起命名冲突。例如下面无法编译通过的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span>RED,BLUE&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Feeling</span> &#123;</span>EXCITED,BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>会隐式转换为int</li><li>用来表征枚举变量的实际类型不能明确指定，从而无法支持枚举类型的前向声明。</li></ul><h2 id="经典做法"><a href="#经典做法" class="headerlink" title="经典做法"></a>经典做法</h2><p>解决作用域不受限带来的命名冲突问题的一个简单方法是，给枚举变量命名时加前缀，如上面例子改成 COLOR_BLUE 以及 FEELING_BLUE。</p><p>一般说来，为了一致性我们会把所有常量统一加上前缀。但是这样定义枚举变量的代码就显得累赘。C 程序中可能不得不这样做。不过 C++ 程序员恐怕都不喜欢这种方法。替代方案是命名空间:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace Color &#123;    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span>    </span></span><br><span class="line"><span class="class">    &#123;</span>        </span><br><span class="line">        RED=<span class="number">15</span>,        </span><br><span class="line">        YELLOW,       </span><br><span class="line">        BLUE    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样之后就可以用 <code>Color::Type c = Color::RED;</code> 来定义新的枚举变量了。如果 <code>using namespace Color</code> 后，前缀还可以省去，使得代码简化。不过，因为命名空间是可以随后被扩充内容的，所以它提供的作用域封闭性不高。在大项目中，还是有可能不同人给不同的东西起同样的枚举类型名。</p><p>更“有效”的办法是用一个类或结构体来限定其作用域，例如：定义新变量的方法和上面命名空间的相同。不过这样就不用担心类在别处被修改内容。这里用结构体而非类，是因为本身希望这些常量可以公开访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color1</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span>   </span></span><br><span class="line"><span class="class">    &#123;</span>        </span><br><span class="line">        RED=<span class="number">102</span>,        </span><br><span class="line">        YELLOW,        </span><br><span class="line">        BLUE    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-11-的枚举类"><a href="#C-11-的枚举类" class="headerlink" title="C++11 的枚举类"></a>C++11 的枚举类</h2><p>上面的做法解决了第一个问题，但对于后两个仍无能为力。庆幸的是，C++11 标准中引入了“枚举类”(enum class)，可以较好地解决上述问题。</p><ul><li>新的enum的作用域不在是全局的</li><li>不能隐式转换成其他类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief C++11的枚举类</span></span><br><span class="line"><span class="comment"> * 下面等价于enum class Color2:int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color2</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    RED=<span class="number">2</span>,    </span><br><span class="line">    YELLOW,    </span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line">r2 c2 = Color2::RED;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(c2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//必须转！</span></span><br></pre></td></tr></table></figure><ul><li>可以指定用特定的类型来存储enum</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color3</span>:</span><span class="type">char</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color3</span>:</span><span class="type">char</span> &#123;    RED=<span class="string">&#x27;r&#x27;</span>,    BLUE&#125;;</span><br><span class="line"><span class="type">char</span> c3 = static_cast&lt;<span class="type">char</span>&gt;(Color3::RED);</span><br></pre></td></tr></table></figure><h2 id="类中的枚举类型"><a href="#类中的枚举类型" class="headerlink" title="类中的枚举类型"></a>类中的枚举类型</h2><p>有时我们希望某些常量只在类中有效。 由于#define 定义的宏常量是全局的，不能达到目的，于是想到实用const 修饰数据成员来实现。而const 数据成员的确是存在的，但其含义却不是我们所期望的。</p><p>const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。</p><p>不能在类声明中初始化 const 数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道 SIZE 的值是什么。(c++11标准前)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;   <span class="comment">// 错误，企图在类声明中初始化 const 数据成员 </span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[SIZE];  <span class="comment">// 错误，未知的 SIZE </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>正确应该在类的构造函数的初始化列表中进行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  A(<span class="type">int</span> size);  <span class="comment">// 构造函数 </span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> SIZE ;    &#125;; </span><br><span class="line">A::A(<span class="type">int</span> size) : SIZE(size)  <span class="comment">// 构造函数的定义</span></span><br><span class="line">&#123; &#125; A  <span class="title function_">a</span><span class="params">(<span class="number">100</span>)</span>; <span class="comment">// 对象 a 的 SIZE 值为 100 </span></span><br><span class="line">A  <span class="title function_">b</span><span class="params">(<span class="number">200</span>)</span>; <span class="comment">// 对象 b 的 SIZE 值为 200 </span></span><br></pre></td></tr></table></figure><p>怎样才能建立在整个类中都恒定的常量呢？</p><p>别指望 const 数据成员了，应该用类中的枚举常量来实现。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>        BOY = <span class="number">0</span>,        GIRL    &#125;SexType;&#125;;</span><br><span class="line"><span class="comment">//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。</span></span><br></pre></td></tr></table></figure><p>枚举常量不会占用对象的存储空间，它们在编译时被全部求值。</p><p>枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点。</p><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>decltype的语法是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (expression)</span><br></pre></td></tr></table></figure><p>这里的括号是必不可少的,decltype的作用是“查询表达式的类型”，因此，上面语句的效果是，返回 expression 表达式的类型。注意，decltype 仅仅“查询”表达式的类型，并不会对表达式进行“求值”。</p><h3 id="1-1-推导出表达式类型"><a href="#1-1-推导出表达式类型" class="headerlink" title="1.1 推导出表达式类型"></a>1.1 推导出表达式类型</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">decltype(i) a; <span class="regexp">//</span>推导结果为<span class="keyword">int</span>。a的类型为<span class="keyword">int</span>。</span><br></pre></td></tr></table></figure><h3 id="1-2-与using-x2F-typedef合用，用于定义类型。"><a href="#1-2-与using-x2F-typedef合用，用于定义类型。" class="headerlink" title="1.2 与using&#x2F;typedef合用，用于定义类型。"></a>1.2 与using&#x2F;typedef合用，用于定义类型。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using <span class="type">size_t</span> = decltype(<span class="keyword">sizeof</span>(<span class="number">0</span>));<span class="comment">//sizeof(a)的返回值为size_t类型</span></span><br><span class="line">using <span class="type">ptrdiff_t</span> = decltype((<span class="type">int</span>*)<span class="number">0</span> - (<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">using <span class="type">nullptr_t</span> = decltype(nullptr);<span class="built_in">vector</span>&lt;<span class="type">int</span> &gt;vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">decltype</span><span class="params">(vec.begin())</span> vectype;</span><br><span class="line"><span class="keyword">for</span> (vectype i = vec.begin; i != vec.end(); i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样和auto一样，也提高了代码的可读性。</p><h3 id="1-3-重用匿名类型"><a href="#1-3-重用匿名类型" class="headerlink" title="1.3 重用匿名类型"></a>1.3 重用匿名类型</h3><p>在C++中，我们有时候会遇上一些匿名类型，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="type">int</span> d ;    <span class="type">double</span> b;&#125;anon_s;</span><br></pre></td></tr></table></figure><p>而借助decltype，我们可以重新使用这个匿名的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(anon_s) as ;<span class="comment">//定义了一个上面匿名的结构体</span></span><br></pre></td></tr></table></figure><h3 id="1-4-泛型编程中结合auto，用于追踪函数的返回值类型"><a href="#1-4-泛型编程中结合auto，用于追踪函数的返回值类型" class="headerlink" title="1.4 泛型编程中结合auto，用于追踪函数的返回值类型"></a>1.4 泛型编程中结合auto，用于追踪函数的返回值类型</h3><p>这也是decltype最大的用途了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">multiply</span><span class="params">(T x, T y)</span>-&gt;<span class="title function_">decltype</span><span class="params">(x*y)</span>&#123;    <span class="keyword">return</span> x*y;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-判别规则"><a href="#2-判别规则" class="headerlink" title="2.判别规则"></a>2.判别规则</h2><p>对于decltype(e)而言，其判别结果受以下条件的影响：</p><p>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&amp;&amp; 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&amp;。 否则，假设e的类型是T，则decltype（e）为T。</p><p>标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>则arr为一个标记符表达式，而arr[3]+0不是。</p><p>举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span> <span class="type">double</span> d; &#125;s ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Overloaded</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Overloaded</span><span class="params">(<span class="type">char</span>)</span>;<span class="comment">//重载的函数</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; <span class="title function_">RvalRef</span><span class="params">()</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> <span class="title function_">Func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：推导为其类型</span></span><br><span class="line">decltype (arr) var1; <span class="comment">//int[] 标记符表达式</span></span><br><span class="line"></span><br><span class="line">decltype (ptr) var2;<span class="comment">//int *  标记符表达式</span></span><br><span class="line"></span><br><span class="line">decltype(s.d) var3;<span class="comment">//doubel 成员访问表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(Overloaded) var4;//重载函数。编译错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则二：将亡值。推导为类型的右值引用。</span></span><br><span class="line"></span><br><span class="line">decltype (RvalRef()) var5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则三：左值，推导为类型的引用。</span></span><br><span class="line"></span><br><span class="line">decltype ((i))var6 = i;     <span class="comment">//int&amp;</span></span><br><span class="line"></span><br><span class="line">decltype (<span class="literal">true</span> ? i : i) var7 = i; <span class="comment">//int&amp;  条件表达式返回左值。</span></span><br><span class="line"></span><br><span class="line">decltype (++i) var8 = i; <span class="comment">//int&amp;  ++i返回i的左值。</span></span><br><span class="line"></span><br><span class="line">decltype(arr[<span class="number">5</span>]) var9 = i;<span class="comment">//int&amp;. []操作返回左值</span></span><br><span class="line"></span><br><span class="line">decltype(*ptr)var10 = i;<span class="comment">//int&amp; *操作返回左值</span></span><br><span class="line"></span><br><span class="line">decltype(<span class="string">&quot;hello&quot;</span>)var11 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//const char(&amp;)[9]  字符串字面常量为左值，且为const左值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则四：以上都不是，则推导为本类型</span></span><br><span class="line"></span><br><span class="line">decltype(<span class="number">1</span>) var12;<span class="comment">//const int</span></span><br><span class="line"></span><br><span class="line">decltype(Func(<span class="number">1</span>)) var13=<span class="literal">true</span>;<span class="comment">//const bool</span></span><br><span class="line"></span><br><span class="line">decltype(i++) var14 = i;<span class="comment">//int i++返回右值</span></span><br></pre></td></tr></table></figure><h1 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h1><h2 id="1-引用与指针"><a href="#1-引用与指针" class="headerlink" title="1.引用与指针"></a>1.引用与指针</h2><p>总论：</p><table><thead><tr><th>引用</th><th>指针</th></tr></thead><tbody><tr><td>必须初始化</td><td>可以不初始化</td></tr><tr><td>不能为空</td><td>可以为空</td></tr><tr><td>不能更换目标</td><td>可以更换目标</td></tr></tbody></table><blockquote><p>引用必须初始化，而指针可以不初始化。</p></blockquote><p>我们在定义一个引用的时候必须为其指定一个初始值，但是指针却不需要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;r;    <span class="comment">//不合法，没有初始化引用</span></span><br><span class="line"><span class="type">int</span> *p;    <span class="comment">//合法，但p为野指针，使用需要小心</span></span><br></pre></td></tr></table></figure><blockquote><p>引用不能为空，而指针可以为空。</p></blockquote><p>由于引用不能为空，所以我们在使用引用的时候不需要测试其合法性，而在使用指针的时候需要首先判断指针是否为空指针，否则可能会引起程序崩溃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_p</span><span class="params">(<span class="type">int</span>* p)</span></span><br><span class="line">&#123;      </span><br><span class="line">    <span class="keyword">if</span>(p != null_ptr)    <span class="comment">//对p所指对象赋值时需先判断p是否为空指针</span></span><br><span class="line">        *p = <span class="number">3</span>;    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test_r</span><span class="params">(<span class="type">int</span>&amp; r)</span></span><br><span class="line">&#123;    </span><br><span class="line">    r = <span class="number">3</span>;    <span class="comment">//由于引用不能为空，所以此处无需判断r的有效性就可以对r直接赋值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用不能更换目标</p></blockquote><p>指针可以随时改变指向，但是引用只能指向初始化时指向的对象，无法改变。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> &amp;r = a;    <span class="comment">//初始化引用r指向变量a</span></span><br><span class="line"><span class="built_in">int</span> *p = &amp;a;   <span class="comment">//初始化指针p指向变量a</span></span><br><span class="line"></span><br><span class="line">p = &amp;b;        <span class="comment">//指针p指向了变量b</span></span><br><span class="line">r = b;         <span class="comment">//引用r依然指向a，但a的值变成了b</span></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><p>C++的引用<strong>在减少了程序员自由度的同时提升了内存操作的安全性和语义的优美性</strong>。比如引用强制要求必须初始化，可以让我们在使用引用的时候不用再去判断引用是否为空，让代码更加简洁优美，避免了指针满天飞的情形。除了这种场景之外引用还用于如下两个场景：</p><blockquote><p>引用型参数</p></blockquote><p>一般我们使用const reference参数作为只读形参，这种情况下既可以避免参数拷贝还可以获得与传值参数一样的调用方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;data)</span>&#123;    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;      <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; data&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;    test(data);&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用型返回值</p></blockquote><p>C++提供了重载运算符的功能，我们在重载某些操作符的时候，使用引用型返回值可以获得跟该操作符原来语法相同的调用方式，保持了操作符语义的一致性。一个例子就是operator []操作符，这个操作符一般需要返回一个引用对象，才能正确的被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(<span class="number">10</span>)</span>;v[<span class="number">5</span>] = <span class="number">10</span>;    <span class="comment">//[]操作符返回引用，然后vector对应元素才能被修改</span></span><br><span class="line">              <span class="comment">//如果[]操作符不返回引用而是指针的话，赋值语句则需要这样写</span></span><br><span class="line">*v[<span class="number">5</span>] = <span class="number">10</span>;   <span class="comment">//这种书写方式，完全不符合我们对[]调用的认知，容易产生误解</span></span><br></pre></td></tr></table></figure><h2 id="3-指针与引用的性能差距"><a href="#3-指针与引用的性能差距" class="headerlink" title="3.指针与引用的性能差距"></a>3.指针与引用的性能差距</h2><p>指针与引用之间有没有性能差距呢？这种问题就需要进入汇编层面去看一下。我们先写一个test1函数，参数传递使用指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* p)</span></span><br><span class="line">&#123;    </span><br><span class="line">    *p = <span class="number">3</span>;    <span class="comment">//此处应该首先判断p是否为空，为了测试的需要，此处我们没加。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码段对应的汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble Dump of assembler code <span class="keyword">for</span> function <span class="title function_">test1</span><span class="params">(<span class="type">int</span>*)</span>:   0x0000000000400886 &lt;+0&gt;:  push   %rbp   0x0000000000400887 &lt;+1&gt;:  mov    %rsp,%rbp   0x000000000040088a &lt;+4&gt;:  mov    %rdi,-0<span class="title function_">x8</span><span class="params">(%rbp)</span>=&gt; <span class="number">0x000000000040088e</span> &lt;+<span class="number">8</span>&gt;:  mov    <span class="number">-0x8</span>(%rbp),%rax   <span class="number">0x0000000000400892</span> &lt;+<span class="number">12</span>&gt;: movl   $<span class="number">0x3</span>,(%rax)   <span class="number">0x0000000000400898</span> &lt;+<span class="number">18</span>&gt;: nop   <span class="number">0x0000000000400899</span> &lt;+<span class="number">19</span>&gt;: pop    %rbp   <span class="number">0x000000000040089a</span> &lt;+<span class="number">20</span>&gt;: retq   End of assembler dump.</span><br></pre></td></tr></table></figure><p>上述代码1、2行是参数调用保存现场操作；第3行是参数传递，函数调用第一个参数一般放在rdi寄存器，此行代码把rdi寄存器值（指针p的值）写入栈中；第4行是把栈中p的值写入rax寄存器；第5行是把立即数3写入到<strong>rax寄存器值所指向的内存</strong>中，此处要注意(%rax)两边的括号，这个括号并并不是可有可无的，(%rax)和%rax完全是两种意义，(%rax)代表rax寄存器中值所代表地址部分的内存，即相当于C++代码中的*p，而%rax代表rax寄存器，相当于C++代码中的p值，所以汇编这里使用了(%rax)而不是%rax。</p><p>我们再写出参数传递使用引用的C++代码段test2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>&amp; r)</span></span><br><span class="line">&#123;    </span><br><span class="line">    r = <span class="number">3</span>;    <span class="comment">//赋值前无需判断reference是否为空</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码对应的汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble Dump of assembler code <span class="keyword">for</span> function <span class="title function_">test2</span><span class="params">(<span class="type">int</span>&amp;)</span>:   0x000000000040089b &lt;+0&gt;:  push   %rbp   0x000000000040089c &lt;+1&gt;:  mov    %rsp,%rbp   0x000000000040089f &lt;+4&gt;:  mov    %rdi,-0<span class="title function_">x8</span><span class="params">(%rbp)</span>=&gt; <span class="number">0x00000000004008a3</span> &lt;+<span class="number">8</span>&gt;:  mov    <span class="number">-0x8</span>(%rbp),%rax   <span class="number">0x00000000004008a7</span> &lt;+<span class="number">12</span>&gt;: movl   $<span class="number">0x3</span>,(%rax)   <span class="number">0x00000000004008ad</span> &lt;+<span class="number">18</span>&gt;: nop   <span class="number">0x00000000004008ae</span> &lt;+<span class="number">19</span>&gt;: pop    %rbp   <span class="number">0x00000000004008af</span> &lt;+<span class="number">20</span>&gt;: retq   End of assembler dump.</span><br></pre></td></tr></table></figure><p>我们发现test2对应的汇编代码和test1对应的汇编代码完全相同，这说明C++编译器在编译程序的时候将指针和引用编译成了完全一样的机器码。所以C++中的引用只是C++对指针操作的一个“语法糖”，在底层实现时C++编译器实现这两种操作的方法完全相同。</p><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h2><p>C++中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，指针与引用底层实现都是一样的，不用担心两者的性能差距。</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="1-宏中包含特殊符号"><a href="#1-宏中包含特殊符号" class="headerlink" title="1.宏中包含特殊符号"></a>1.宏中包含特殊符号</h2><p>分为几种：<code>#</code>，<code>##</code>，<code>\</code></p><h3 id="1-1-字符串化操作符（-）"><a href="#1-1-字符串化操作符（-）" class="headerlink" title="1.1 字符串化操作符（#）"></a>1.1 字符串化操作符（#）</h3><p><strong>在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组</strong>，换言之就是：**#是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串**。</p><p><strong>注意：其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> exp(s) printf(<span class="string">&quot;test s is:%s\n&quot;</span>,s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp1(s) printf(<span class="string">&quot;test s is:%s\n&quot;</span>,#s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp2(s) #s </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="built_in">exp</span>(<span class="string">&quot;hello&quot;</span>);    </span><br><span class="line">    exp1(hello);    </span><br><span class="line">    <span class="built_in">string</span> str = exp2(   bac );    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略传入参数名前面和后面的空格。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">string</span> str1 = exp2( asda  bac );    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，</span></span><br><span class="line"><span class="comment">     * 用每个子字符串之间以一个空格连接，忽略剩余空格。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str1.size()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码给出了基本的使用与空格处理规则，空格处理规则如下：</p><ul><li>忽略传入参数名前面和后面的空格。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = exp2(   bac );</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bac</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = exp2( asda  bac );</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">asda</span> bac <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="1-2-符号连接操作符（-）"><a href="#1-2-符号连接操作符（-）" class="headerlink" title="1.2 符号连接操作符（##）"></a>1.2 符号连接操作符（##）</h3><p><strong>“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。</strong></p><p>注意事项：</p><p><strong>（1）当用##连接形参时，##前后的空格可有可无。</strong></p><p><strong>（2）连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。</strong></p><p><strong>（3）如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> expA(s) printf(<span class="string">&quot;前缀加上后的字符串为:%s\n&quot;</span>,gc_##s)  <span class="comment">//gc_s必须存在</span></span></span><br><span class="line"><span class="comment">// 注意事项2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> expB(s) printf(<span class="string">&quot;前缀加上后的字符串为:%s\n&quot;</span>,gc_  ##  s)  <span class="comment">//gc_s必须存在</span></span></span><br><span class="line"><span class="comment">// 注意事项1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc_hello1 <span class="string">&quot;I am gc_hello1&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    <span class="comment">// 注意事项1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * gc_hello = <span class="string">&quot;I am gc_hello&quot;</span>;    </span><br><span class="line">    expA(hello);    </span><br><span class="line">    expB(hello1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-续行操作符（-）"><a href="#1-3-续行操作符（-）" class="headerlink" title="1.3 续行操作符（\）"></a>1.3 续行操作符（\）</h3><p><strong>当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。</strong></p><p><strong>注意 \ 前留空格。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b) ? (a) \   :(b))  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> max_val = MAX(<span class="number">3</span>,<span class="number">6</span>);    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max_val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-do-…-while-0-的使用"><a href="#2-do-…-while-0-的使用" class="headerlink" title="2.do{…}while(0)的使用"></a>2.do{…}while(0)的使用</h2><h3 id="2-1-避免语义曲解"><a href="#2-1-避免语义曲解" class="headerlink" title="2.1 避免语义曲解"></a>2.1 避免语义曲解</h3><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="function"><span class="title">fun</span><span class="params">()</span></span> f1();f2();</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这个宏被展开后就是：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure><p>本意是a&gt;0执行f1 f2，而实际是f2每次都会执行，所以就错误了。</p><p>为了解决这种问题，在写代码的时候，通常可以采用<code>&#123;&#125;</code>块。</p><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fun() &#123;f1();f2();&#125;</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)    fun();</span><br><span class="line"><span class="comment">// 宏展开</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;    f1();    f2();&#125;;</span><br></pre></td></tr></table></figure><p>但是会发现上述宏展开后多了一个分号，实际语法不太对。(虽然编译运行没问题，正常没分号)。</p><h3 id="2-2避免使用goto控制流"><a href="#2-2避免使用goto控制流" class="headerlink" title="2.2避免使用goto控制流"></a>2.2避免使用goto控制流</h3><p>在一些函数中，我们可能需要在return语句之前做一些清理工作，比如释放在函数开始处由malloc申请的内存空间，使用goto总是一种简单的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));    </span><br><span class="line">    *p = <span class="number">10</span>;     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG    </span></span><br><span class="line">    <span class="type">int</span> error=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(error)        </span><br><span class="line">        <span class="keyword">goto</span> END;    <span class="comment">// dosomething</span></span><br><span class="line">END:    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;free&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，这个时候我们可以使用do{…}while(0)来做同样的事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ff</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));    </span><br><span class="line">    *p = <span class="number">10</span>;     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">do</span>&#123; </span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> DEBUG        </span></span><br><span class="line">        <span class="type">int</span> error=<span class="number">1</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>        </span></span><br><span class="line">        <span class="keyword">if</span>(error)            </span><br><span class="line">        <span class="keyword">break</span>;        <span class="comment">//dosomething  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;free&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将函数主体部分使用do{…}while(0)包含起来，使用break来代替goto，后续的清理工作在while之后，现在既能达到同样的效果，而且代码的可读性、可维护性都要比上面的goto代码好的多了。</p><h3 id="2-3-避免由宏引起的警告"><a href="#2-3-避免由宏引起的警告" class="headerlink" title="2.3 避免由宏引起的警告"></a>2.3 避免由宏引起的警告</h3><p>内核中由于不同架构的限制，很多时候会用到空宏，。在编译的时候，这些空宏会给出warning，为了避免这样的warning，我们可以使用do{…}while(0)来定义空宏：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#define</span> EMPTYMICRO <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-定义单一的函数块来完成复杂的操作"><a href="#2-4-定义单一的函数块来完成复杂的操作" class="headerlink" title="2.4 定义单一的函数块来完成复杂的操作"></a>2.4 <strong>定义单一的函数块来完成复杂的操作</strong></h3><p>如果你有一个复杂的函数，变量很多，而且你不想要增加新的函数，可以使用do{…}while(0)，将你的代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。 这种情况应该是指一个变量多处使用（但每处的意义还不同），我们可以在每个do-while中缩小作用域，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fc</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> k1 = <span class="number">10</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;k1&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">do</span>&#123;        </span><br><span class="line">        <span class="type">int</span> k1 = <span class="number">100</span>;        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;k1&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;k1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/17056.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/posts/17056.html" class="post-title-link" itemprop="url">FMCW Radar</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-07 10:57:51" itemprop="dateCreated datePublished" datetime="2022-10-07T10:57:51+08:00">2022-10-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-22 21:02:56" itemprop="dateModified" datetime="2023-01-22T21:02:56+08:00">2023-01-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">-note</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="FMCW雷达工作原理"><a href="#FMCW雷达工作原理" class="headerlink" title="FMCW雷达工作原理"></a>FMCW雷达工作原理</h1><p>毫米波 (mmWave) 是一类使用短波长电磁波的特殊雷达技术。雷达系统发射的电磁波信号被其发射路径上的物体阻挡继而会发生反射。通过捕捉反射的信号，雷达系统可以确定物体的距离、速度和角度。</p><p>毫米波雷达可发射波长为毫米量级的信号。在电磁频谱中，这种波长被视为短波长，也是该技术的优势之一。诚然，处理毫米波信号所需的系统组件（如天线）的尺寸确实很小。短波长的另一项优势是高准确度。工作频率为 76–81GHz（对应波长约为 4mm）的毫米波系统将能够检测小至零点几毫米的移动。<br>完整的毫米波雷达系统包括发送 (TX) 和接收 (RX) 射频 (RF) 组件，以及时钟等模拟组件，还有模数转换器 (ADC)、微控制器 (MCU) 和数字信号处理器 (DSP) 等数字组件。过去，这些系统都是通过分立式组件实现的，这增加了功耗和总体系统成本。其复杂性和高频率要求使得系统设计颇具挑战性。<br>顾名思义，FMCW 雷达连续发射调频信号，以测量距离以及角度和速度。这与周期性发射短脉冲的传统脉冲雷达系统不同。</p><p>在雷达系统中，其基本概念是指电磁信号发射过程中被其发射路径上的物体阻挡进行的反射。FMCW 雷达系统所用信号的频率随时间变化呈线性升高。这种类型的信号也称为线性调频脉冲。下图以幅度（振幅）相对时间的函数，显示了线性调频脉冲信号表示。</p><img src="..\images\FMCW%20Radar\1.png" alt="" data-align="center"><p>下图为同一个线性调频脉冲信号（频率作为时间的函数）。该线性调频脉冲具有起始频率 ($f_c$)、带宽($B$) 和持续时间 ($T_c$)。持续时间$T_c$上的 FMCW 信号称为啁啾（chirp），也叫做调频信号， 调频信号的频率随时间以线性增加。该线性调频脉冲的斜率 ($S$) 捕捉频率的变化率。在例子中图提供的示例中，$f_c&#x3D; 77 GHz$ ，$B&#x3D; 4 GHz$ ，$T_c&#x3D; 40 µs$ ，$S&#x3D; 100 MHz&#x2F;µs$ 。</p><img src="../images/FMCW%20Radar/2.png" alt="" data-align="center"><p>FMCW 雷达系统发射线性调频脉冲信号，并捕捉其发射路径中的物体反射的信号。下图所示为 FMCW 雷达主射频组件的简化框图。该雷达的工作原理如下：<img src="../images/FMCW%20Radar/3.png" alt="" data-align="center"></p><ul><li><p>信号源生成一个线性调频脉冲$x_T(t)$。</p></li><li><p>该线性调频脉冲由发射天线（TX 天线）发射。</p></li><li><p>物体对该线性调频脉冲的反射生成一个由接收天线（RX 天线）捕捉的反射线性调频脉冲$x_R(t)$。</p></li><li><p>“混频器”将 RX 和 TX 信号合并到一起，生成一个中频 (IF) 信号$x_{IF}(t)$。</p></li></ul><h2 id="单周期动目标分析"><a href="#单周期动目标分析" class="headerlink" title="单周期动目标分析"></a>单周期动目标分析</h2><p>发射的FMCW 信号可以用正弦函数表示为:</p><p>$$<br>x_T(t)&#x3D;A_0 \cos[2 \pi (f_c t + \frac{1}{2} S t^2) + \phi_0]<br>&#x3D;A_0 \cos(2 \pi f_c t + \pi S t^2 + \phi_0)<br>\tag{1}<br>$$</p><p>其中，$A_0$，$\phi_0$分别为发射信号的振幅和初始相位，$f_c$是发射信号的中心频率，$S&#x3D;\frac{B}{T_c}$为调频斜率，$B$为有效带宽，$T_c$为有效时宽。</p><p>发射信号的瞬时相位和频率分别可以表示为：</p><p>$$<br>P_T(t) &#x3D; 2 \pi (f_c t + \frac{1}{2} S t^2) + \phi_0 \tag{2}<br>$$</p><p>$$<br>f_T(t) &#x3D; f_c + S t \tag{3}<br>$$</p><p>假定目标模型为：</p><p>$$<br>R(t) &#x3D; R_0 + vt \tag{4}<br>$$</p><p>其中，$R_0$为目标初始距离（$t&#x3D;0$），$v$为目标径向速度（远离雷达为正方向），则目标的瞬时回波时延可表示为：</p><p>$$<br>\tau(t) &#x3D; \frac{2R(t)}{c}&#x3D;\tau_0 + \frac{2v}{t} \tag{5}<br>$$</p><p>其中，$\tau_0&#x3D;\frac{R_0}{c}$为目标初始时延，$c$为光速。</p><p>故，接收天线接收到的回波信号和瞬时相位可以分别表示为：</p><p>$$<br>x_R(t) &#x3D; K_r A_0 \cos P_R(t) \tag{6}\<br>P_R(t) &#x3D; 2 \pi { f_c[t - \tau(t)] + \frac{1}{2} S [t-\tau(t)]^2 } + \phi_0 + \theta_0<br>$$</p><p>其中，$\theta_0$为目标反射引起的附加相移，$K_r$为目标反射系数（回波强度），它由目标的雷达截面积（Radar Cross-Section，RCS）决定，RCS越大，$K_r$越大。</p><img src="../images/FMCW%20Radar/4.png" alt="" data-align="center"><p>若目标保持静止，当发射和接收的调频信号在时间上重叠时，中频信号频率（即拍频）在有效接收周期内保持恒定，如上图所示存在恒定频率差$\tau_0&#x3D;\frac{2R_0}{c}$，实际中速度带来了多普勒频移，会使得回波频率（图中虚线）沿坐标轴上移（或下移）。为了得到中频信号，接收信号经过混频器与发射信号混频，得到的中频信号可以表示为：</p><p>$$<br>x_{IF}(t) &#x3D; K_r A_0^2 \cos P_{IF}(t) \<br>P_{IF}(t) &#x3D; P_R(t) - P_T(t) &#x3D; -2\pi [f_c\tau(t) + St\tau(t) - \frac{1}{2}S\tau(t)^2] + \theta_0<br>\tag{7}<br>$$</p><p>将公式（5）带入公式（7）可得：</p><p>$$<br>P_{IF}(t) &#x3D; 2\pi[(S\frac{2R_0}{c}-\frac{4v}{c^2}R_0<br>+\frac{2v}{c}f_c)t<br>+(\frac{2v}{c}S-\frac{2v^2}{c^2}S)t^2 \<br>+(f_s\frac{2R_0}{c}-S\frac{2R_0^2}{c^2})] - \theta_0 &#x3D; 2\pi(f_bt + S_bt^2 - \theta_0)<br>\tag{8}<br>$$</p><p>其中，$f_b &#x3D; S\frac{2R_0}{c}-\frac{4v}{c^2}R_0+\frac{2v}{c}f_c$，$S_b &#x3D; \frac{2v}{c}S-\frac{2v^2}{c^2}S$，显然，中频信号也是线性连续调频波。目前讨论为匀速运动，但如果目标具有加速度，数学表达式将变得非常复杂，此处不做讨论，实际情况中，可以将动目标的变速运动看做分段匀速运动处理。</p><p>基于$v \ll c$的条件，公式可以进行省略为：</p><p>$$<br>P_{IF}(t) \approx 2\pi[(S\frac{2R_0}{c}+\frac{2v}{c}f_c) t - \theta_0] \<br>f_b \approx S\frac{2R_0}{c} + \frac{2v}{c}f_c \tag{9}<br>$$</p><p>由$f_b$的公式可知，频谱误差和扫频周期成正比，也就是说处理周期越多，频谱对于实际的频谱的偏差越大；并且速度越大，频谱偏差也越大，这是LFMCW系统与生俱来的缺陷：速度距离耦合。造成速度距离耦合的本质原因在于LFMCW的扫频周期远远大于回波时延，所以LFMCW是一种大时延信号。</p><h2 id="多周期动目标分析"><a href="#多周期动目标分析" class="headerlink" title="多周期动目标分析"></a>多周期动目标分析</h2><p>基于单周期的动目标分析，假设当前为第k个周期，则当前发射信号的表达式为：</p><p>$$<br>x_{T,k}(t)&#x3D;A_0 \cos { 2 \pi [f_c (t-kT_c) + \frac{1}{2} S (t-kT_c)^2] + \phi_0 }<br>\tag{10}<br>$$</p><p>假定目标模型为：</p><p>$$<br>R(t) &#x3D; R_0 + vt \tag{11}<br>$$</p><p>则目标的回波信号可表示为：</p><p>$$<br>x_{R,k} &#x3D; K_r A_0 \cos P_{R,k}(t) \<br>\tag{12}<br>$$</p><p>$$<br>P_{R,k}(t) &#x3D; 2 \pi { f_c[t - kT_c -\tau(t)] + \frac{1}{2} S [t - kT_c - \tau(t)]^2 } + \phi_0 + \theta_0<br>$$</p><p>对应的中频信号为：</p><p>$$<br>x_{IF,k}(t) &#x3D; K_r A_0^2 \cos P_{IF,k}(t) \<br>\tag{13}<br>$$</p><p>$$<br>P_{IF,k}(t) &#x3D; 2\pi[S\frac{2v}{c}(1-\frac{v}{c})t^2 +(S\frac{2R_k}{c}(1-\frac{2v}{c})+\frac{2v}{c}f_c)t +(f_c\frac{2R_k}{c}-S\frac{2R_k^2}{c^2})] - \theta_0<br>$$</p><p>其中，$R_k &#x3D; R_0 + vkT_C$。</p><p>基于$v \ll c$和$R_0 S \ll c f_c$的条件，公式可以进行省略为：</p><p>$$<br>P_{IF,k}(t) &#x3D; -2\pi(f_bt + f_dkT_c) + \Phi_0<br>\tag{14}<br>$$</p><p>其中，$f_d&#x3D;\frac{2v}{c}f_c$，$\Phi_0&#x3D;-2\pi(f_c\tau_0-\frac{1}{2}S\tau_0^2)+\theta_0$，$f_b &#x3D; \frac{2v}{c}f_c+S\frac{2R_k}{c}(1-\frac{2v}{c}) \approx f_d + S\frac{2R_k}{c} \approx f_d + S\tau_0$。由此，我们可以看到中频信号不仅在$t$轴上受到$f_b$的调制（体现为距离和速度的耦合），还在$kT$轴上受到多普勒频率$f_d$的调制。</p><p>通过分别在在t轴和kT轴上进行FFT变换即可求得$f_d$和$f_b$的值，进而推算出速度和距离，但只有当$f_d &lt; \frac{1}{T_c}$时，即目标的多普勒速度不模糊时，该计算方法才是正确的，因此，通常采用对称三角LFMCW雷达进行参数估计。</p><img src="../images/FMCW%20Radar/5.png" alt="" data-align="center"><p>对于对称三角LFMCW，需要对上、下扫频的中频信号进行FFT运算，分别得到$f_R^+$和$f_R^-$，然后经过以下式子计算得到：</p><p>$$<br>f_d &#x3D; f_d^+ &#x3D; f_d^- &#x3D; \frac{f_R^+ + f_R^-}{2} \tag{15}<br>$$</p><p>$$<br>\tau_0 &#x3D; \frac{f_R^+ - f_R^-}{2S} \tag{16}<br>$$</p><p>$$<br>R_0 &#x3D; \frac{c}{2} \tau_0 \<br>v &#x3D; \frac{\lambda}{2} f_d<br>\tag{17}<br>$$</p><p>但该方法，在多目标环境中，如何对上&#x2F;下扫频段目标进行准确配对存在较大的难点。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/59171.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/posts/59171.html" class="post-title-link" itemprop="url">Radar System Classification</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-06 21:49:29" itemprop="dateCreated datePublished" datetime="2022-10-06T21:49:29+08:00">2022-10-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-10-07 11:47:40" itemprop="dateModified" datetime="2022-10-07T11:47:40+08:00">2022-10-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">-note</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>雷达系统有各种尺寸和不同的性能规格。一些雷达系统用于机场的空中交通管制，其他雷达系统用于远程监视和预警系统。雷达系统是导弹制导系统的核心。可以使用一个人维护和操作的小型便携式雷达系统以及占用几个大房间的系统。</p><h1 id="Classification-of-Radar-Systems"><a href="#Classification-of-Radar-Systems" class="headerlink" title="Classification of Radar Systems"></a>Classification of Radar Systems</h1><p>根据所需信息，雷达设备必须具有不同的qualities和technologies，这些不同qualities和technologies雷达装置分为：</p><p><img src="/..%5Cimages%5C1.png"></p><h2 id="Imaging-Radar-x2F-Non-Imaging-Radar"><a href="#Imaging-Radar-x2F-Non-Imaging-Radar" class="headerlink" title="Imaging Radar &#x2F; Non-Imaging Radar"></a>Imaging Radar &#x2F; Non-Imaging Radar</h2><p>成像雷达传感器测量坐标的两个维度，至少用于计算雷达波束覆盖区域的类似地图的图像。成像雷达形成观察到的物体或区域的图像。成像雷达已用于绘制地球、其他行星、小行星和其他天体的地图，并对军事系统的目标进行分类。</p><p>非成像传感器在一个线性维度上进行测量，而不是成像传感器的二维表示。非成像雷达系统的典型实现是speed gauges和radar altimeters，这些也被称为scatterometers，因为它们测量被观测物体或区域的散射特性。非成像辅助雷达应用是最近一些私家车的防盗系统。</p><h2 id="Primary-Radar"><a href="#Primary-Radar" class="headerlink" title="Primary Radar"></a>Primary Radar</h2><p>Primary Radar发射在目标处反射的高频信号，接收并评估产生的回波。这意味着，与二次雷达装置不同，一次雷达装置再次接收自身发射的信号作为回波。主雷达装置通常配备一个额外的询问器作为辅助雷达，以结合两种系统的优点。</p><h2 id="Pulse-Radar"><a href="#Pulse-Radar" class="headerlink" title="Pulse Radar"></a>Pulse Radar</h2><p>脉冲雷达装置发射高功率的高频脉冲信号。在这个脉冲信号之后，在发出新的发射信号之前，会有一个较长的中断，在此中断中可以接收回波。可以根据测量的天线位置和脉冲信号的传播时间来确定目标的方向、距离，有时还可以根据需要确定目标的高度或高度。这些典型的雷达装置发射非常短的脉冲（以获得良好的距离分辨率）和极高的脉冲功率（以获得较好的最大距离）。</p><h3 id="Pulse-Radar-using-Pulse-Compression"><a href="#Pulse-Radar-using-Pulse-Compression" class="headerlink" title="Pulse Radar using Pulse Compression"></a>Pulse Radar using Pulse Compression</h3><p>这些雷达装置发射的脉冲相对较弱，脉冲宽度较长。它调制发射信号，以借助脉冲压缩在发射脉冲内获得距离分辨率。</p><h3 id="Monostatic-x2F-Bistatic-Radars"><a href="#Monostatic-x2F-Bistatic-Radars" class="headerlink" title="Monostatic &#x2F; Bistatic Radars"></a>Monostatic &#x2F; Bistatic Radars</h3><p>Monostatic radars部署在一个地点。配置发射机和接收机，雷达大多使用同一天线。Bistatic Radars由一个分开（相当远的距离）的发射和接收站点组成。</p><h2 id="Secondary-Radar"><a href="#Secondary-Radar" class="headerlink" title="Secondary Radar"></a>Secondary Radar</h2><p>在二次雷达装置上，飞机必须有一个应答器（发射应答器），该应答器通过发送编码应答信号来响应询问。此响应包含的信息比主雷达单元能够获取的信息多得多（例如高度、识别码或船上的任何技术问题，例如无线电联系丢失……）。</p><h3 id="Principle-of-operation"><a href="#Principle-of-operation" class="headerlink" title="Principle of operation"></a>Principle of operation</h3><p>地面上的询问器以不同的模式发送编码脉冲。每种模式代表一个不同的问题。对于传统的SSR（即非S模式），问题的选择非常简单。管制员想知道飞机的身份（“你是谁？”）。雷达提供了飞机的二维定位，但空中交通管制在很大程度上是一个三维过程，所以“你的高度是多少？”完成位置修复。这些不同的问题决定了操作模式。飞机应答器用代码应答。</p><p><img src="/..%5Cimages%5C2.png"></p><p>所选模式在编码器中编码。（通过不同的模式，可以为飞机定义不同的问题。）发射机用射频频率调制这些编码脉冲。因为在询问路径上使用了重播路径以外的另一个频率，所以可以放弃昂贵的双工器。天线通常安装在主雷达单元的天线上（如图所示），因此与监视器上的偏转同步转动。</p><p>飞机上有一个接收天线和一个应答器。接收器放大并解调询问脉冲。解码器根据所需信息解码问题，并诱导编码器准备合适的答案。编码器对答案进行编码。发射机放大重放脉冲，并用射频应答频率对其进行调制。</p><p>同样在地面的询问机中：接收器放大并解调回放脉冲。干扰或干扰信号在此尽可能被过滤掉。解码器根据信息“Mode”和“Code”解码答案。主雷达的显示表示附加询问器信息。也许额外的数字必须显示在额外的显示器上。</p><h3 id="Comparison-Primary-Radar-vs-Secondary-Radar"><a href="#Comparison-Primary-Radar-vs-Secondary-Radar" class="headerlink" title="Comparison Primary Radar vs. Secondary Radar"></a>Comparison Primary Radar vs. Secondary Radar</h3><p>Primary Radar单元有一个主要特点：它可以处理被动回波。发射的高频脉冲被目标反射，然后被同一雷达单元接收，反射回波的直接原因是雷达装置发出的发射脉冲。</p><p>Secondary Radar装置根据另一个原理工作：它们与主动应答信号一起工作。第二雷达单元发射和接收高频脉冲，即所谓的询问。这不仅仅是反射，而是目标通过接收和处理的应答器接收。在此之后，目标以另一频率应答，即生成并发送的响应报文。</p><p>由于原理不同，这两种系统各有优缺点。如果使用Primary Radar获得有关目标方向、高度和距离的安全信息，则Secondary Radar仍会提供其他信息，如信号识别和目标高度。</p><p>在相同最大射程的情况下，目标（应答器）的合作对于大幅降低发射功率是必要的。因为发射功率影响双向行进的主雷达的雷达方程，而二次监视雷达只有单向。可以假设系数&gt;1000作为指导值。由此，一种更简单、更小、更便宜的发射机应运而生。由于主动应答的功率高于被动回波的功率，因此接收器可能更不敏感。然而，这种情况会对旁瓣的影响产生不利影响。这必须通过使用适当的旁瓣抑制措施进行补偿。由于发射频率和接收频率不同，因此不会产生杂波干扰。因此，无需MTI系统来补偿地杂波。另一方面，干扰不可能改变频率。二次雷达设备的特殊干扰使得有必要采取额外的布线措施。</p><h2 id="Continuous-Wave-Radar"><a href="#Continuous-Wave-Radar" class="headerlink" title="Continuous Wave Radar"></a>Continuous Wave Radar</h2><p>连续波雷达装置连续发射高频信号，接收并处理回波信号。该设备传输的信号在振幅和频率上是恒定的，必须用这一原则解决两个问题：</p><ul><li><p>防止传输能量直接连接到接收器（反馈连接）；</p></li><li><p>将接收到的回波分配给时间系统，以便能够执行运行时间<br>测量。</p></li></ul><p>可通过以下方式防止传输能量直接连接到接收器：</p><ul><li><p>发射天线和接收天线的空间分离，例如，目标由强大的发射器照明，接收器位于朝向目标的导弹飞行方向；</p></li><li><p>测速过程中多普勒频率的频率相关分离。</p></li></ul><p>speed gauges不需要进行运行时间测量，违章车辆的实际行驶距离没有影响。如果需要距离信息，则可以通过对发射功率进行频率调制或相位键控来实现时间测量。发射未调制功率的连续波雷达只能通过多普勒效应测量速度。它无法测量范围，也无法区分两个反射对象。</p><h3 id="Block-Diagram-of-an-CW-Radar"><a href="#Block-Diagram-of-an-CW-Radar" class="headerlink" title="Block Diagram of an CW-Radar"></a>Block Diagram of an CW-Radar</h3><p>简单的连续波多普勒雷达装置的设计如图所示。</p><p><img src="/..%5Cimages%5C3.png"></p><p>第一个生成器产生非常稳定的射频$f_s$ ，第二个生成器生成中频频率$f_{ZF}$ 。带有以下窄带滤波器的混频器级生成稳定的本地振荡器频率$f_s+f_{ZF}$，作为发射机频率和生成的中频频率之和。作为超外差接收机的一部分，下一混频器级将后向散射射频信号$f_s+f_{D}$转换为中频频率。中频放大器使接收器对微弱回波信号非常敏感。最后一个混频器级的输出仅为多普勒频率$f_D$。频率计数器对多普勒频率进行计数，并通过该计数值计算速度。为了获得精确的结果，必须根据精确规定的车道辐射角校准此计算程序。</p><h3 id="Speed-gauges"><a href="#Speed-gauges" class="headerlink" title="Speed gauges"></a>Speed gauges</h3><p>速度计是一种非常专业的连续波雷达。发射未调制功率时，它只能利用多普勒效应测量速度。它无法测量范围，也无法区分两个反射对象。速度表不需要进行运行时间测量，违章车辆的实际行驶距离没有影响。如果需要距离信息，则可以通过对发射功率进行频率调制或相位键控来实现时间测量。</p><h3 id="Frequency-Modulated-CW-radar"><a href="#Frequency-Modulated-CW-radar" class="headerlink" title="Frequency Modulated CW radar"></a>Frequency Modulated CW radar</h3><p><img src="/..%5Cimages%5C4.png"></p><p>连续波雷达的缺点是无法测量距离，因为没有时间脉冲。为了纠正此问题，可以使用频率偏移方法。在频移法中，频率围绕固定基准不断变化的信号用于检测静止物体。当接收到反射时，可以检查频率，通过了解过去发出特定频率的时间，可以进行类似于使用脉冲的范围计算。通常，要制作一个能够清晰地发送随机频率的广播电台并不容易，因此，这些调频连续波雷达（FMCW）使用平稳变化的频率上下“斜坡”。</p><p>$$<br>R &#x3D; \frac{c_0 \cdot \Delta t}{2} \tag{1}<br>$$</p><p>$c_0$ &#x3D; speed of light &#x3D; 3·108 m&#x2F;s</p><p>$\Delta t$ &#x3D; measured time-difference [s]</p><p>$R$ &#x3D; distance altimeter to terrain [m]</p><p>这种雷达经常被用作“radar altimeter”。radar altimeter用于测量飞机着陆过程中的准确高度。雷达高度计也是地形回避警告系统的一个组成部分，它告诉飞行员飞机飞得太低或地形上升，无法与飞机相遇。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="%5BRadartutorial%5D(https://www.radartutorial.eu/druck/index.en.html)">radartutorial.eu</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/39212.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/posts/39212.html" class="post-title-link" itemprop="url">Radar Antenna Techniques</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-05 16:04:13" itemprop="dateCreated datePublished" datetime="2022-10-05T16:04:13+08:00">2022-10-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-22 21:04:15" itemprop="dateModified" datetime="2023-01-22T21:04:15+08:00">2023-01-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">-note</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Radar-Antenna-Techniques"><a href="#Radar-Antenna-Techniques" class="headerlink" title="Radar Antenna Techniques"></a>Radar Antenna Techniques</h1><p>天线（antenna）这个名字源于意大利发明家伽利尔摩·马可尼（Guglielmo Marconi）的工作。在他进行电磁波实验时，他使用了一根木质帐篷杆，上面装有辐射线。这个帐篷杆在意大利语中的意思是l’antenna。在描述马可尼的实验时，这个术语的普遍使用导致了发射机站点的这个组成部分的流行名称“天线”。</p><p>天线发射或接收电磁波，是一种将电磁波转换为高频电流的传感器。天线的机械尺寸是所用波长的分数，因此有使用长波范围频率的长度超过百米的天线，以及用于微波范围的长度为几毫米的天线。</p><h2 id="Functions-of-an-Antenna"><a href="#Functions-of-an-Antenna" class="headerlink" title="Functions of an Antenna"></a>Functions of an Antenna</h2><p>天线是雷达系统中最关键的部件之一，执行以下基本功能：</p><ul><li><p>以所需的分布和效率将发射机能量传输到空间的信号，此过程以相同的方式应用于接收。</p></li><li><p>确保在空间中拥有所需要的模式。通常，必须在方位角上足够窄，以提供所需的角分辨率和距离分辨率。</p></li><li><p>提供所需的目标位置更新频率。</p></li><li><p>以高精度测量指向方向。</p></li></ul><p>雷达的基本性能与天线面积或孔径与平均发射功率的乘积成正比。因此，对天线的投资将直接影响系统性能。考虑到这些功能和雷达天线所需的效率，通常采用两种天线：</p><ul><li><p>抛物面天线（ parabolic dish antenna）。</p></li><li><p>阵列天线（array antenna）。</p></li></ul><h2 id="Antenna-Characteristics"><a href="#Antenna-Characteristics" class="headerlink" title="Antenna Characteristics"></a>Antenna Characteristics</h2><h3 id="Gain"><a href="#Gain" class="headerlink" title="Gain"></a>Gain</h3><p>一些天线源向各个方向均匀辐射能量。这种辐射称为各向同性辐射（isotropic radiation）。</p><p>所有的其他天线都具有与各向同性辐射相反的增益。有些天线方向性很强，也就是说，在某些方向传播的能量比在其他方向传播的要多。在这些方向传播的能量与天线不定向时传播的能量之比称为增益。当使用具有一定增益的发射天线作为接收天线时，它也将具有相同的接收增益。</p><h3 id="Antenna-Pattern"><a href="#Antenna-Pattern" class="headerlink" title="Antenna Pattern"></a>Antenna Pattern</h3><p>大多数辐射器在一个方向上比在另一个方向放射出更强的辐射。这样的辐射器称为各向异性（anisotropic）。然而，标准方法允许标记源周围的位置，以便可以轻松地将一种辐射模式与另一种进行比较。</p><p>天线辐射出的能量会形成具有一定辐射方向图的场。因此，辐射方向图是绘制天线辐射能量的一种方法，该能量是在距离天线恒定距离的不同角度处测量的，而辐射方向图的形状取决于所用天线的类型。</p><p>为了绘制此模式，使用了两种不同类型的图形，矩形坐标图和极坐标图。极坐标图已被证明在研究辐射模式方面有很大的用途。在极坐标图中，点是通过沿旋转轴（半径）投影到与几个同心、等间距圆之一的交点来定位的，测量辐射的极坐标图如下图所示。</p><img src="../images/r-1.png" alt="" data-align="center"><ul><li><p>主波束（main beam）或主瓣（main lobe），是最大辐射方向周围的区域（通常是在主波束峰值3 dB以内的区域），图中的主瓣向北。</p></li><li><p>旁瓣（sidelobes）是远离主波束的较小波束。这些旁瓣通常是在不希望的方向上的辐射，永远无法完全消除。副瓣电平是表征辐射模式的一个重要参数。</p></li><li><p>其中一个副瓣称为后瓣（backlobe）。这是辐射方向与主光束方向相反的部分。</p></li></ul><p>下图中的图形显示了同一源的矩形坐标图。在直角坐标图中，点是通过一对固定的垂直轴的投影来定位的。矩形坐标图上的水平轴对应于极坐标图中的圆。矩形坐标图上的垂直轴对应于极坐标图中的旋转轴（半径）。图表中的测量刻度可以是线性的，也可以是对数的。</p><img src="../images/r-2.png" alt="" data-align="center"><p>根据绘制的天线方向图，可以测量天线的一些重要特性：</p><ul><li><p>前后比（front-to-back ratio），定向天线前后之间的功率增益比（图中180度的副瓣值：34dB）。</p></li><li><p>旁瓣比（side lobe ratio），即远离主波束的旁瓣的最大值。（在图中，副瓣的值，例如+6度：20dB）。</p></li></ul><h4 id="Beam-Width"><a href="#Beam-Width" class="headerlink" title="Beam Width"></a>Beam Width</h4><p>仍发射至少一半最大功率的天线方向图的角范围称为“波束”（beam with）。因此，该主瓣的边界点是室内场强相对于最大场强下降约3 dB的点。然后，该角度被描述为波束宽度（beam width），孔径角（aperture angle）或半功率（-3 dB）角，并带有符号$\Theta$（也称为$\varphi$）。波束宽度$\Theta$正好是图中两个黑色标记功率电平之间的角度。角度$\Theta$可以在水平面（用符号$\Theta_{AZ}$）和垂直面（用标记$\Theta_{EL}$）中确定。</p><h4 id="Aperture"><a href="#Aperture" class="headerlink" title="Aperture"></a>Aperture</h4><p>各向同性辐射器在球体表面分散所有能量。功率在给定距离内具有规定的密度。定向天线将能量集中在较小的区域，功率密度高于各向同性散热器。密度也可以表示为单位面积的功率。接收到的功率与相关面积成比例，该区域称为有效孔径（effective aperture）。</p><p>天线的有效孔径$A_e$是辐射或接收信号的面积，是控制天线性能的关键参数，天线增益与有效面积的关系如下：</p><p>$$<br>G&#x3D;\frac{4\pi \cdot A_e}{\lambda^2} \<br>A_e &#x3D; K_a \cdot A<br>\tag{1}<br>$$</p><p>$\lambda$ &#x3D; wavelength<br>$A_e$ &#x3D; effective antenna aperyure<br>$A$ &#x3D; physical area of the antenna<br>$K_a$ &#x3D; antenna aperture efficency</p><h4 id="Major-and-Minor-Lobes"><a href="#Major-and-Minor-Lobes" class="headerlink" title="Major and Minor Lobes"></a>Major and Minor Lobes</h4><p>上图所示的辐射集中在几个瓣。一个瓣的辐射强度比另一个叶瓣得多。最强的叶称为主瓣；其他是（小）旁瓣。由于与阵列相关的复杂辐射模式通常包含几个强度不同的波瓣。一般来说，主瓣是辐射量最大的瓣。侧瓣或小瓣是辐射强度最小的瓣。</p><h4 id="Front-to-back-Ratio"><a href="#Front-to-back-Ratio" class="headerlink" title="Front-to-back Ratio"></a>Front-to-back Ratio</h4><p>前后比是定向天线前后之间的功率增益比。在大多数情况下，天线模式图中有一个独特的后瓣。有时你找不到一个与主瓣正好相反的波瓣，在这种情况下，前后比是指主瓣相反方向±10至±30度范围内的最大旁瓣。需要较高的前后比是为了在不需要的方向上辐射的能量最小。</p><h3 id="Polarization"><a href="#Polarization" class="headerlink" title="Polarization"></a>Polarization</h3><img src="../images/r-3.png" alt="" data-align="center"><p>天线的辐射场由电力线和磁力线组成。这些力线总是彼此成直角。这个<br>电场决定波的极化方向。当使用单线天线从经过的无线电波中提取能量时，当天线朝向与电场相同的方向时，将产生最大的提取效果。</p><p>电场的振荡可以是单向的（线性极化），或者电场的振荡方向可以随着波的传播而旋转（圆极化或椭圆极化）。</p><h4 id="Linear-Polarization"><a href="#Linear-Polarization" class="headerlink" title="Linear Polarization"></a>Linear Polarization</h4><p>垂直和水平安装的接收天线分别用于接收垂直和水平极化波。因此，由于天线无法接收极化变化，极化变化会导致接收信号电平的变化。主要使用两个极化平面：</p><ul><li><p>在垂直极化波中，电力线位于垂直方向。</p></li><li><p>在水平极化波中，电力线位于水平方向。</p></li></ul><p>线性极化显然可以取所有平面，但除了水平面和垂直面之外。当使用单线天线从经过的无线电波中提取能量时，当天线朝向与电场相同的方向时，将产生最大的拾提取效果。因此，垂直天线用于有效接收垂直极化波，水平天线用于接收水平极化波。</p><h4 id="Circular-Polarization"><a href="#Circular-Polarization" class="headerlink" title="Circular Polarization"></a>Circular Polarization</h4><img src="../images/r-4.png" alt="" data-align="center"><p>圆极化使电力线在每一个射频能量循环中旋转360度。圆极化由两个90°相移输入信号和同时移动90°的平面极化天线产生。选择电场作为参考场，因为波的强度通常是根据电场强度（伏特、毫伏或微伏&#x2F;米）来测量的。在某些情况下，电场的方向并不保持不变。相反，磁场随着波在空间中传播而旋转。在这些条件下，场的水平分量和垂直分量都存在，波的极化为椭圆。</p><p>圆极化可以是右手极化，也可以是左手极化。圆极化波被球形雨滴反射，透射方向相反。在接收时，天线会抑制圆极化方向相反的波，从而最大限度地减少对雨水的探测。目标的反射在原始偏振意义上具有重要成分，因为与雨不同，飞机不是球形的。因此，相对于雨水，目标信号的强度增强。</p><p>为了最大限度地吸收电磁场的能量，接收天线必须位于同一极化平面。如果使用了错误极化的天线，则会产生相当大的损耗，实际上在20到30 dB之间。</p><h2 id="Half-wave-Antenna"><a href="#Half-wave-Antenna" class="headerlink" title="Half-wave Antenna"></a>Half-wave Antenna</h2><img src="../images/r-5.png" alt="" data-align="center"><p>半波天线（称为偶极子、赫兹或偶极子）由两段线材或管子组成，每根线材或导管在特定频率下的波长为1&#x2F;4。它是构造许多复杂天线的基本单元。对于偶极子，电流在中心最大，在末端最小。电压在中心最小，在端部最大。</p><img src="../images/r-6.png" alt="" data-align="center"><p>能量也可以通过将天线在其中心分开，并将传输线从最终发射机输出级连接到对半天线的两个中心端，馈送到半波天线。由于天线现在是在中心馈电（低电压和高电流点），这种馈电类型称为中心馈电或电流馈电方法。馈电点在确定要使用的传输线类型时非常重要。</p><p>电流和电压的驻波类似于并联振荡电路。然而，与增益精确为1的各向同性辐射器相反，半波天线的增益约为1.5，而最大辐射来自于垂直于天线轴的方向。</p><p>半波偶极子来自一个简单的振荡电路。假设振荡电路的电容板分开稍微弯曲，现在容量减少了，但电容器仍然是一个电容器。当电容板进一步分开时，电场的力线必须覆盖越来越大的范围。电容器的形状已无法识别。电场的力线穿过自由空间。出现了一个半波偶极子，现在正在中心馈电。</p><h3 id="Parabolic-Antennae"><a href="#Parabolic-Antennae" class="headerlink" title="Parabolic Antennae"></a>Parabolic Antennae</h3><img src="../images/r-7.png" alt="" data-align="center"><p>抛物面碟形天线是雷达工程中最常用的安装天线类型，上图显示了抛物面天线。碟形天线由一个圆形抛物面反射器和一个位于该反射器焦点上的点源组成。该点源称为“主馈电”或“馈电”。</p><p>圆形抛物面（抛物面）反射器由金属制成，通常是一个内部由金属网覆盖的框架。金属网槽的宽度必须小于λ&#x2F;10。该金属覆盖物形成反射器，用作雷达能量的镜子。</p><p>根据光学定律和分析几何学，对于这种类型的反射器，所有反射光线都将平行于抛物面的轴，理想情况下，抛物面会有一条反射光线平行于主轴，没有旁瓣。该场使馈电喇叭具有球形波前。当波前的每一部分到达反射面时，它的相位会偏移180度，并以一定角度向外发送，从而使场的所有部分以平行路径传播。</p><p>这是一个理想化的雷达天线，可以产生铅笔波束。如果反射器为椭圆形，则会产生扇形光束。监视雷达在水平面和垂直面上使用两种不同的曲率，以实现所需的方位角铅笔波束和仰角经典余割平方扇形波束。</p><img src="../images/r-8.png" alt="" data-align="center"><p>上图所示的这种理想情况在实践中并不发生。由于生产中的不规则性，实际抛物面天线方向图呈锥形。该主瓣的角宽度可能会有所不同，从某些雷达装置的1到2度到其他雷达的15到20度不等。抛物面天线的辐射方向图包含一个沿传播轴定向的主瓣和几个小的副瓣，这种类型的反射器可以产生非常窄的光束。</p><p>抛物面反射器天线的增益G可以确定如下：</p><p>$$<br>G≈\frac{160^2}{\Theta_{AZ} \cdot \Theta_{El}}<br>$$</p><p>$\Theta_{AZ}$ &#x3D; beamwidth in azimuth angle</p><p>$\Theta_{El}$ &#x3D; beamwidth in elevation angle</p><h3 id="Fan-Beam-Antenna"><a href="#Fan-Beam-Antenna" class="headerlink" title="Fan-Beam Antenna"></a>Fan-Beam Antenna</h3><p>具有抛物面反射器的天线的增益G可以确定如下：扇形波束天线是一种定向天线，它产生一个在一个维度上具有窄波束宽度，在另一个维度具有更宽波束宽度的主波束。这种图案可以通过照亮抛物面的不对称部分获得，例如通过截断抛物面反射器。由于反射器在垂直面上较窄，在水平面上较宽，因此它产生的光束在垂直面内较宽，而在水平面内较窄。</p><img src="../images/r-9.png" alt="" data-align="center"><p>这种类型的天线系统通常用于测高设备（如果反射器旋转90度）。由于反射器在水平面上较窄，在垂直面上较宽，因此它产生的光束在水平面内较宽，而在垂直面内较窄。在形状上，测高雷达的波束是一个水平扇形波束图，如图所示。角馈天线不安装在天线的中间，而是更侧向，类似于商业卫星接收器的碟形天线，这种馈电称为偏置天线。</p><h3 id="Offset-Antenna"><a href="#Offset-Antenna" class="headerlink" title="Offset Antenna"></a>Offset Antenna</h3><img src="../images/r-10.png" alt="" data-align="center"><p>与馈电喇叭相关的一个问题是，如果馈电喇叭位于波束路径中，则会产生阴影。阴影是馈电喇叭正前方的一个死点。通常，馈电喇叭会阻碍抛物面天线上来自反射器的射线。为了解决这个问题，馈电喇叭可以从中心偏移。在偏移馈线中，馈线位于波的路径之外，因此不会因孔径阻塞而导致图案恶化。喇叭相对于抛物线的轴朝上，抛物线的下半部被移除。净效应是抛物线较浅，焦距较大。因此，馈电喇叭距离反射器更远，需要更大的方向性，以避免能量溢出。因此，这种设计需要更大的喇叭，而且通常建造起来更困难、更昂贵。</p><h2 id="Phased-Array-Antenna"><a href="#Phased-Array-Antenna" class="headerlink" title="Phased Array Antenna"></a>Phased Array Antenna</h2><h3 id="Principle-of-Operation"><a href="#Principle-of-Operation" class="headerlink" title="Principle of Operation"></a>Principle of Operation</h3><p>相控阵天线由许多辐射元件组成，每个辐射元件带有一个移相器。波束是通过改变每个辐射元件发出的信号的相位形成的，以提供constructive&#x2F;destructive interference，从而将波束转向所需的方向。</p><img src="../images/r-11.png" alt="" data-align="center"><p>在图中，两个辐射元件都是用同一相位馈电的。信号通过主方向上的constructive interference而放大。破坏性干涉提高了光束锐度。</p><img src="../images/r-12.png" alt="" data-align="center"><p>在图中，信号由下部辐射元件发射，相移比上部辐射元件早10度。因此，发射和信号的主方向向上移动。（注：图中使用的辐射元件没有反射器。因此，所示天线图的后瓣与主瓣一样大。）</p><img src="../images/r-13.png" alt="" data-align="center"><p>主波束总是指向相移增加的方向。如果要辐射的信号现在通过电子移相器传递，从而产生连续的相移，那么波束方向将是电子可调的。然而，这不能无限扩展。相控阵天线的视野（FOV）可以达到的最高值为120°（左60°和右60°）。利用正弦定理，可以计算出必要的相位移动。</p><h3 id="Linear-Array"><a href="#Linear-Array" class="headerlink" title="Linear Array"></a>Linear Array</h3><img src="../images/r-14.png" alt="" data-align="center"><p>这些天线由线组成，这些线的元件围绕一个公共移相器转动。若干相互垂直安装的线性阵列构成一个平面天线。</p><h3 id="Planar-Array"><a href="#Planar-Array" class="headerlink" title="Planar Array"></a>Planar Array</h3><img src="../images/r-15.png" alt="" data-align="center"><p>这些天线阵列完全由单个辐射单元组成，每个单元都有自己的计算机控制移相器。元素在矩阵数组中排序。所有元件的平面布置构成完整的相控阵天线。</p><ul><li><p>优点：可以在两个平面上进行光线偏转</p></li><li><p>缺点：布置复杂，需要更多的电子控制移相器</p></li></ul><p>安排波束偏转的处理器需要较高的处理能力。移相器通常通过串行总线系统进行控制。每个辐射元件一个附加的受控衰减器可以组成各种波束形状。如果雷达装置安装在移动平台上，处理器还必须考虑波束偏转，计算平台的俯仰和横摇。</p><h3 id="Frequency-Scanning-Array"><a href="#Frequency-Scanning-Array" class="headerlink" title="Frequency Scanning Array"></a>Frequency Scanning Array</h3><img src="../images/r-16.png" alt="" data-align="center"><p>频率扫描是相控阵天线的一种特殊情况，其中通过激励的频率扫描实现主波束转向，波束转向是传输频率的函数，这种天线称为频率扫描阵列。通常的安排是从一个折叠波导馈送不同的辐射元件。频率扫描阵列是相控阵天线串行馈电类型的特例，它基于波导中波传播的特殊特性。正常频率下，两个辐射元件之间的相位差为n·360°。</p><p>通过改变频率，改变主波束轴线与阵列天线法线之间的角度$\Theta_{S}$。使用以下原理生成高度信息：</p><ul><li><p>如果发射频率上升，则波束沿天线表面传播；</p></li><li><p>如果发射频率下降，则波束沿天线表面向下传播。</p></li></ul><p>随着频率的变化，波束轴将改变，扫描可以在仰角完成。雷达装置的设计使其能够在频率传输时跟踪频率，然后检测并将返回的频率转换为3D显示数据。请注意，频率扫描降低了使用频率变化作为实现其他有价值效果的手段的价值（脉冲压缩的好处）。</p><h3 id="Phase-Shifter"><a href="#Phase-Shifter" class="headerlink" title="Phase Shifter"></a>Phase Shifter</h3><img src="../images/r-17.png" alt="" data-align="center"><p>移相器切换不同的迂回线路比调节器更快。图中显示了雷达装置中使用的4位开关移相器。不同的绕行线路被切换到信号道。因此，在0°和337.5°之间以22.5°的距离步进创建了16个不同的相位角。</p><p>电感（作为低通滤波器的细弯曲导线）也可以在总共24针二极管的开关电压电源中识别。</p><p>由于该移相器模块既适用于传输方式，也适用于接收方式，因此这两条路径之间的分支与模块入口和出口处陶瓷带上的引脚二极管开关相连。</p><p>接收时间和发送时刻必须使用相同的数据字。很容易理解：这一个散热器，发射最新的相移，首先接收回波信号。它的移相器必须有最大的绕行线，以便在确定的方向上形成图形。接收能量和视频脉冲的总和需要相同的绕行线。</p><p>移相器将微波信号通过不同长度的电缆传输给每个辐射元件。电缆延迟波，从而改变输出的相对相位。图中显示了每个移相器可以引入的三个基本延迟。这些开关是快速引脚二极管开关。中央计算机计算移相器路径适当组合中每个辐射元件和开关的适当相位延迟。</p><h2 id="Monopulse-Antennae"><a href="#Monopulse-Antennae" class="headerlink" title="Monopulse Antennae"></a>Monopulse Antennae</h2><p>在这个概念下，天线组合成一个天线阵列，在馈电中有一种特殊的方法：单个天线元件并不总是在一起同相切换！对于不同的目的，接收到的能量可以形成各种总和和差值。</p><img src="../images/r-18.png" alt="" data-align="center"><p>在使用单脉冲天线的主雷达装置中，所有天线元件都是同相馈电的，并总结了辐射方向图。某些组仅在接收时间中进行汇总，其总和或差异为自己的接收频道提供信息。然后将所有信号作为视频处理器功能进行比较，并使用它们的差异更准确地估计目标的方位。因此，它可以以更低的每次扫描命中率运行。</p><p>在使用单脉冲天线的二次雷达装置中，脉冲组在和信道上传输，在差信道上传输额外的脉冲。单脉冲天线用于旁瓣抑制。这两个例子说明：单脉冲天线不是一个自己的基本天线模型。单脉冲天线可以构造为一组对数周期天线、一组简单的偶极辐射器或贴片天线场。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="%5BRadartutorial%5D(https://www.radartutorial.eu/druck/index.en.html)">radartutorial.eu</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/16107.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/posts/16107.html" class="post-title-link" itemprop="url">Hello World</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-27 20:35:31" itemprop="dateCreated datePublished" datetime="2022-09-27T20:35:31+08:00">2022-09-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-10-07 10:32:46" itemprop="dateModified" datetime="2022-10-07T10:32:46+08:00">2022-10-07</time></span></div></header><div class="post-body" itemprop="articleBody"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Kqnonrime" src="/images/wx.jpg"><p class="site-author-name" itemprop="name">Kqnonrime</p><div class="site-description" itemprop="description">轻推门扉，至见花影</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Kqnonrime" src="/images/wx.jpg"><p class="site-author-name" itemprop="name">Kqnonrime</p><div class="site-description" itemprop="description">轻推门扉，至见花影</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas" style="width:100%"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">-C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radar/" rel="tag">-Radar</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radar-Antenna/" rel="tag">-Radar Antenna</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32F103/" rel="tag">-STM32F103</a><span class="tag-list-count">1</span></li></ul></canvas></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; Tue Sep 27 2022 08:00:00 GMT+0800 (中国标准时间) – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Kqnonrime</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共29.5k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hibiki.model.json"},display:{position:"right",width:150,height:350},mobile:{show:!1},log:!1})</script></body></html>