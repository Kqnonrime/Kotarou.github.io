<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"kqnonrime.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"manual",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="const常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。 1.const作用 可以定义常量  1const int a&#x3D;100;   类型检查  const定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。 其他情况下它只是一个 const 限定的变量，不要将与常量混淆。   防止修改，起保护作用，增加程序健壮性   123void f"><meta property="og:type" content="article"><meta property="og:title" content="C++ Basics"><meta property="og:url" content="https://kqnonrime.github.io/posts/9323.html"><meta property="og:site_name" content="群青学院"><meta property="og:description" content="const常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。 1.const作用 可以定义常量  1const int a&#x3D;100;   类型检查  const定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。 其他情况下它只是一个 const 限定的变量，不要将与常量混淆。   防止修改，起保护作用，增加程序健壮性   123void f"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-10-18T08:40:53.000Z"><meta property="article:modified_time" content="2022-10-19T04:09:10.046Z"><meta property="article:author" content="Kqnonrime"><meta property="article:tag" content="-C++"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://kqnonrime.github.io/posts/9323.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++ Basics | 群青学院</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">群青学院</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kqnonrime.github.io/posts/9323.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/wx.jpg"><meta itemprop="name" content="Kqnonrime"><meta itemprop="description" content="轻推门扉，至见花影"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="群青学院"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++ Basics</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-18 16:40:53" itemprop="dateCreated datePublished" datetime="2022-10-18T16:40:53+08:00">2022-10-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-10-19 12:09:10" itemprop="dateModified" datetime="2022-10-19T12:09:10+08:00">2022-10-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">-note</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>常类型是指使用类型修饰符<strong>const</strong>说明的类型，常类型的变量或对象的值是不能被更新的。</p><h2 id="1-const作用"><a href="#1-const作用" class="headerlink" title="1.const作用"></a>1.const作用</h2><ul><li>可以定义常量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><ul><li><p>类型检查</p><ul><li>const定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。</li><li>其他情况下它只是一个 <code>const</code> 限定的变量，不要将与常量混淆。</li></ul></li><li><p>防止修改，起保护作用，增加程序健壮性</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>&#123;    </span><br><span class="line">    i++; <span class="comment">//error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以节省空间，避免不必要的内存分配</p><ul><li>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像<code>#define</code>一样给出的是立即数。</li><li>const定义的常量在程序运行过程中只有一份拷贝，而<code>#define</code>定义的常量在内存中有若干个拷贝。</li></ul></li></ul><h2 id="2-const对象默认为文件局部变量"><a href="#2-const对象默认为文件局部变量" class="headerlink" title="2.const对象默认为文件局部变量"></a>2.const对象默认为文件局部变量</h2><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><blockquote><p>未被const修饰的变量在不同文件的访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">int</span> ext;</span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(ext+<span class="number">10</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>const常量在不同文件的访问</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extern_file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext=<span class="number">12</span>;</span><br><span class="line"><span class="comment">//extern_file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ext&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结：<br>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p></blockquote><h2 id="3-定义常量"><a href="#3-定义常量" class="headerlink" title="3.定义常量"></a>3.定义常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;b = <span class="number">0</span>; <span class="comment">// error: assignment of read-only variable ‘b’</span></span><br><span class="line"><span class="type">const</span> <span class="built_in">string</span> s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i,j=<span class="number">0</span> <span class="comment">// error: uninitialized const ‘i’</span></span><br></pre></td></tr></table></figure><p>上述有两个错误：</p><ul><li>b 为常量，不可更改！</li><li>i 为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</li></ul><h2 id="4-指针与const"><a href="#4-指针与const" class="headerlink" title="4.指针与const"></a>4.指针与const</h2><p>与指针相关的const有四种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * a; <span class="comment">//指向const对象的指针或者说指向常量的指针。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>小结：</strong><br>如果<em>const</em>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于<code>*</code>的右侧，<em>const</em>就是修饰指针本身，即指针本身是常量。</p></blockquote><p>具体使用如下：</p><p>（1） <strong>指向常量的指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;*ptr = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</p><p>除此之外，也不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> * vp = &amp;p;</span><br><span class="line"><span class="type">void</span> *vp = &amp;p; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>另外一个重点是：<strong>允许把非const对象的地址赋给指向const对象的指针</strong>。</p><p>将非const对象的地址赋给const对象的指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">int</span> val = <span class="number">3</span>;ptr = &amp;val; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</p><p>我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr1 = &amp;val;*ptr1=<span class="number">4</span>;<span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>小结：<br>1.对于指向常量的指针，不能通过指针来修改对象的值。<br>2.不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p></blockquote><p>（2） <strong>常指针</strong></p><p>const指针必须进行初始化，且const指针的值不能修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;    </span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//const指针必须初始化！且const指针的值不能修改</span></span><br><span class="line">    <span class="type">int</span> * t = &amp;num;    </span><br><span class="line">    *t = <span class="number">1</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述修改ptr指针所指向的值，可以通过非const指针来修改。</p><p>最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int<code>*</code> -&gt; int <code>*</code>错误！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num=<span class="number">0</span>;    </span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//error! const int* -&gt; int*</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述若改为 const int <code>*</code>ptr或者改为const int <code>*</code>const ptr，都可以正常！</p><p>（3）<strong>指向常量的常指针</strong></p><p>理解完前两种情况，下面这个情况就比较好理解了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> ptr = &amp;p; </span><br></pre></td></tr></table></figure><p>ptr是一个const指针，然后指向了一个int 类型的const对象。</p><h2 id="5-函数中使用const"><a href="#5-函数中使用const" class="headerlink" title="5.函数中使用const"></a>5.函数中使用const</h2><blockquote><p>const修饰函数返回值</p></blockquote><p>这个跟const修饰普通变量以及指针的含义基本相同：</p><p>（1）<strong>const int</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这个本身无意义，因为参数返回本身就是赋值给其他的变量！</p><p>（2）<strong>const int</strong>*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="title function_">func2</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>指针指向的内容不变。</p><p>（3）int *const</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>指针本身不可变。</p><blockquote><p>const修饰函数参数</p></blockquote><p>（1）传递过来的参数及指针本身在函数内不可变，无意义！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span>; <span class="comment">// 传递过来的参数不可变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> var)</span>; <span class="comment">// 指针本身不可变</span></span><br></pre></td></tr></table></figure><p>表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</p><p>输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</p><p>（2）<strong>参数指针所指内容为常量不可变</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p><p>（3）<strong>参数为引用，为了增加效率同时防止修改。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span><br></pre></td></tr></table></figure><p>对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p><p>为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。</p><blockquote><p>但是函数void func(A &amp;a) 存在一个缺点：</p><p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p></blockquote><p>以此类推，是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p><blockquote><p>小结：<br>1.对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。</p><p>2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</p></blockquote><p>以上解决了两个面试问题：</p><ul><li>如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；</li><li>如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。</li></ul><h2 id="6-类中使用const"><a href="#6-类中使用const" class="headerlink" title="6.类中使用const"></a>6.类中使用const</h2><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。</p><p>对于类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line">public:</span><br><span class="line">    Apple(<span class="type">int</span> i);     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::Apple(<span class="type">int</span> i):apple_number(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apple.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line">public:</span><br><span class="line">    Apple(<span class="type">int</span> i);     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apple.cpp&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Apple::Apple(<span class="type">int</span> i):apple_number(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Apple::add</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    take(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Apple::add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span><br><span class="line">&#123;    </span><br><span class="line">    take(num);    </span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Apple::take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;take func &quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Apple::getCount</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;    </span><br><span class="line">    take(<span class="number">1</span>);    </span><br><span class="line">    add();  <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> apple_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    Apple <span class="title function_">a</span><span class="params">(<span class="number">2</span>)</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.getCount()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    a.add(<span class="number">10</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译： g++ -o main main.cpp apple.cpp</p></blockquote><p>此时报错，上面getCount()方法中调用了一个add方法，而add方法并非const修饰，所以运行报错。也就是说const成员函数只能访问const成员函数。</p><p>当调用改为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Apple <span class="title">b</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">b.<span class="keyword">add</span>(); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>此时，可以证明的是const对象只能访问const成员函数。</p><p>我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：</p><p>第一：将常量定义与static结合，也就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number</span><br></pre></td></tr></table></figure><p>第二：在外面初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>当然，如果你使用c++11进行编译，直接可以在定义处初始化，可以直接写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这两种都在c++11中支持！</p><p>编译的时候加上<code>-std=c++11</code>即可！</p><p>这里提到了static，下面简单的说一下：</p><p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</p><p>在类中声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> ap;</span><br></pre></td></tr></table></figure><p>在类实现文件中使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Apple::ap=<span class="number">666</span></span><br></pre></td></tr></table></figure><p>对于此项，c++11不能进行声明并初始化，也就是上述使用方法。</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>当与不同类型一起使用时，Static关键字具有不同的含义：</p><p><strong>静态变量：</strong> 函数中的变量，类中的变量</p><p><strong>静态类的成员：</strong> 类对象和类中的函数</p><p><strong>静态变量</strong></p><ul><li>函数中的静态变量</li></ul><p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在C &#x2F; C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> #<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">()</span> </span><br><span class="line">&#123;     <span class="comment">// static variable </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;         <span class="comment">// value is updated and </span></span><br><span class="line">    <span class="comment">// will be carried to next </span></span><br><span class="line">    <span class="comment">// function calls </span></span><br><span class="line">    count++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;     </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)             </span><br><span class="line">    demo();     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><ul><li>类中的静态变量</li></ul><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public:     </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;         </span><br><span class="line">    Apple()     </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="comment">// Do nothing </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    Apple obj1; </span><br><span class="line">    Apple obj2; </span><br><span class="line">    obj1.i = <span class="number">2</span>; </span><br><span class="line">    obj2.i = <span class="number">3</span>;     </span><br><span class="line">    <span class="comment">// prints value of i </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj1.i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;obj2.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>您可以在上面的程序中看到我们已经尝试为多个对象创建静态变量i的多个副本。但这并没有发生。因此，类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public:     </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;         </span><br><span class="line">    Apple()     </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="comment">// Do nothing    </span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;     </span><br><span class="line">    Apple obj;     <span class="comment">// prints value of i </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.i; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>静态成员</strong></p><ul><li>类对象为静态</li></ul><p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p><ul><li>类中的静态函数</li></ul><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>this指针的用处：</p><p>（1）一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p><p>（2）this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</p><p>this指针的使用：</p><p>（1）在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。</p><p>（2）当参数与成员变量名相同时，如this-&gt;n &#x3D; n （不能写成n &#x3D; n)。</p><p>现有如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>        </span><br><span class="line">    BOY = <span class="number">0</span>,         </span><br><span class="line">    GIRL     </span><br><span class="line">&#125;SexType;    </span><br><span class="line">Person(<span class="type">char</span> *n, <span class="type">int</span> a,SexType s)</span><br><span class="line">&#123;        </span><br><span class="line">    name=new <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>];        </span><br><span class="line">    <span class="built_in">strcpy</span>(name,n);        </span><br><span class="line">    age=a;        </span><br><span class="line">    sex=s;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="type">int</span> <span class="title function_">get_age</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;            </span><br><span class="line">    <span class="keyword">return</span> this-&gt;age;     </span><br><span class="line">&#125;    </span><br><span class="line">Person&amp; <span class="title function_">add_age</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;        </span><br><span class="line">    age+=a;        </span><br><span class="line">    <span class="keyword">return</span> *this;     </span><br><span class="line">&#125;    </span><br><span class="line">~Person()</span><br><span class="line">&#123;        </span><br><span class="line">    delete [] name;    </span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">char</span> * name;    </span><br><span class="line">    <span class="type">int</span> age;    </span><br><span class="line">    SexType sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    Person <span class="title function_">p</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>,Person::BOY)</span>;     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.get_age()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p.add_age(<span class="number">10</span>).get_age()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：this在成员函数的开始执行前构造，在成员的执行结束后清除。上述的get_age函数会被解析成<code>get_age(const A * const this)</code>,<code>add_age</code>函数会被解析成<code>add_age(A* const this,int a)</code>。在C++中类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了。</p><h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><ul><li><p>如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收货会更少！</p></li><li><p>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p></li></ul><p>以下情况不宜用内联：</p><p>（1）如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</p><p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><p>对于虚函数：</p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><ul><li>空类的大小为1字节</li><li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li><li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</li><li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li><li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li><li>虚继承,继承基类的vptr。</li></ul><h2 id="1-原则1"><a href="#1-原则1" class="headerlink" title="1.原则1"></a>1.原则1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file blackclass.cpp</span></span><br><span class="line"><span class="comment"> * @brief 空类的大小为1字节</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-原则2"><a href="#2-原则2" class="headerlink" title="2.原则2"></a>2.原则2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file static.cpp</span></span><br><span class="line"><span class="comment"> * @brief 静态数据成员</span></span><br><span class="line"><span class="comment"> * 静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。 </span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    public:</span><br><span class="line">        <span class="type">char</span> b;        </span><br><span class="line">        virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;&#125;;        </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c;        </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> d;        </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 16  字节对齐、静态变量不影响类的大小、vptr指针=8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-原则3"><a href="#3-原则3" class="headerlink" title="3.原则3"></a>3.原则3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file morevir.cpp</span></span><br><span class="line"><span class="comment"> * @brief 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span>;    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span>;    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-原则4与5"><a href="#4-原则4与5" class="headerlink" title="4.原则4与5"></a>4.原则4与5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file geninhe.cpp</span></span><br><span class="line"><span class="comment"> * @brief 1.普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)</span></span><br><span class="line"><span class="comment"> * 注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。</span></span><br><span class="line"><span class="comment"> * 2.虚单继承，派生类继承基类vptr</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    public:</span><br><span class="line">        <span class="type">char</span> a;        <span class="type">int</span> b;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 此时B按照顺序：</span></span><br><span class="line"><span class="comment"> * char a</span></span><br><span class="line"><span class="comment"> * int b</span></span><br><span class="line"><span class="comment"> * short a</span></span><br><span class="line"><span class="comment"> * long b</span></span><br><span class="line"><span class="comment"> * 根据字节对齐4+4+8+8=24</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 或编译器优化</span></span><br><span class="line"><span class="comment"> * char a</span></span><br><span class="line"><span class="comment"> * short a</span></span><br><span class="line"><span class="comment"> * int b</span></span><br><span class="line"><span class="comment"> * long b</span></span><br><span class="line"><span class="comment"> * 根据字节对齐2+2+4+8=16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>A&#123;    public:</span><br><span class="line">        <span class="type">short</span> a;        <span class="type">long</span> b;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把A的成员拆开看，char为1，int为4，所以是1+（3）+4+1+（3）=12，（）为字节补齐</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span>    A a;    <span class="type">char</span> c;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span></span></span><br><span class="line"><span class="class">&#123;</span>    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>:</span>public A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16 或 24</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 对于虚单函数继承，派生类也继承了基类的vptr，所以是8字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C1)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-原则6"><a href="#5-原则6" class="headerlink" title="5.原则6"></a>5.原则6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file virnhe.cpp</span></span><br><span class="line"><span class="comment"> * @brief 虚继承</span></span><br><span class="line"><span class="comment"> * @author 光城</span></span><br><span class="line"><span class="comment"> * @version v1</span></span><br><span class="line"><span class="comment"> * @date 2019-07-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> virtual public  A, virtual public B</span><br><span class="line">&#123;    </span><br><span class="line">    public:</span><br><span class="line">        virtual <span class="type">void</span> <span class="title function_">fun3</span><span class="params">()</span> </span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 8 8 16  派生类虚继承多个虚函数，会继承所有虚函数的vptr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(C);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><h2 id="1-纯虚函数与抽象类"><a href="#1-纯虚函数与抽象类" class="headerlink" title="1.纯虚函数与抽象类"></a>1.纯虚函数与抽象类</h2><p>C++中的纯虚函数(或抽象函数)是没有实现的虚函数！只需声明它! 通过声明中赋值0来声明纯虚函数！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line">Class A &#123;</span><br><span class="line">public:     </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> = <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="comment">/* Other members */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>纯虚函数：没有函数体的虚函数</li><li>抽象类：包含纯虚函数的类</li></ul><p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象,抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</p><h2 id="2-实现抽象类"><a href="#2-实现抽象类" class="headerlink" title="2.实现抽象类"></a>2.实现抽象类</h2><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数&#x2F;析构函数内部不能使用纯虚函数。</p><p>如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A为抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> = <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">g</span><span class="params">()</span>&#123; this-&gt;f(); &#125;    </span><br><span class="line">    A()&#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B:f()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  <span class="comment">// 实现了抽象类的纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-重要点"><a href="#3-重要点" class="headerlink" title="3.重要点"></a>3.重要点</h2><ul><li>纯虚函数使一个类变成抽象类</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">public:     </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> = <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 普通成员函数</span></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">     <span class="type">int</span> x; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>抽象类类型的指针和引用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123; </span><br><span class="line">public:     </span><br><span class="line">    <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In Derived \n&quot;</span>; &#125; <span class="comment">// 实现抽象类的纯虚函数</span></span><br><span class="line">    Derived()&#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;     </span><br><span class="line">    <span class="comment">//Base b;  // error! 不能创建抽象类的对象</span></span><br><span class="line">    <span class="comment">//Base *b = new Base(); error!</span></span><br><span class="line"></span><br><span class="line">    Base *bp = new Derived(); <span class="comment">// 抽象类的指针和引用 -&gt; 由抽象类派生出来的类的对象</span></span><br><span class="line">    bp-&gt;show();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Derived为抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base &#123; </span><br><span class="line">public: </span><br><span class="line"><span class="comment">//    void show() &#123;&#125;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>抽象类可以有构造函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>     </span><br><span class="line">protected:         </span><br><span class="line">    <span class="type">int</span> x;     </span><br><span class="line">public:         </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> = <span class="number">0</span>;         </span><br><span class="line">    Base(<span class="type">int</span> i) &#123; x = i; &#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base &#123;     </span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">public:     </span><br><span class="line">    Derived(<span class="type">int</span> i, <span class="type">int</span> j) : Base(i) &#123; y = j; &#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>构造函数不能是虚函数，而析构函数可以是虚析构函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Base()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor: Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;    </span><br><span class="line">    virtual ~Base()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor : Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;        </span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    Derived()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor: Derived&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;    </span><br><span class="line">    ~Derived()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor : Derived&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;        </span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;In Derived.func().&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。 如果析构函数不是虚拟的，则只能调用基类析构函数。</p></blockquote><h1 id="C-虚函数的vptr与vtable"><a href="#C-虚函数的vptr与vtable" class="headerlink" title="C++虚函数的vptr与vtable"></a>C++虚函数的vptr与vtable</h1><p>为了实现虚函数，C ++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态&#x2F;后期绑定方式的函数调用函数的查找表。虚拟表有时会使用其他名称，例如“vtable”，“虚函数表”，“虚方法表”或“调度表”。</p><p>虚拟表实际上非常简单，虽然用文字描述有点复杂。首先，<strong>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表</strong>。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p><p>其次，编译器还会添加一个隐藏指向基类的指针，我们称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p><p>因此，它使每个类对象的分配大一个指针的大小。这也意味着vptr由派生类继承，这很重要。</p><h1 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h1><p><strong>虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。</strong></p><p><strong>默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型</strong>。</p><p>（1） <strong>静态函数可以声明为虚函数吗？</strong></p><p>原因主要有两方面：</p><p><strong>静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰</strong></p><p>static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义</p><p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。</p><p>（2）<strong>构造函数可以为虚函数吗？</strong></p><p>构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。</p><p>为什么构造函数不可以为虚函数？</p><p>尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。</p><p>我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。 因此，构造函数没有必要被声明为虚函数。</p><p>（3）<strong>析构函数可以为虚函数吗？</strong></p><p><strong>析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。</strong></p><p>（4）<strong>虚函数可以为私有函数吗？</strong></p><ul><li>基类指针指向继承类对象，则调用继承类对象的函数；</li><li>int main()必须声明为Base类的友元，否则编译失败。 编译器报错： ptr无法访问私有函数。 当然，把基类声明为public， 继承类为private，该问题就不存在了。</li></ul><p>（5）<strong>虚函数可以被内联吗？</strong></p><p><strong>通常类成员函数都会被编译器考虑是否进行内联。 但通过基类指针或者引用调用的虚函数必定不能被内联。 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。</strong></p><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><p>RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%BA%E7%B1%BB/9589663">基类</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>或引用来检查这些指针或引用所指的对象的实际<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B4%BE%E7%94%9F%E7%B1%BB">派生类</a>型。</p><p>在面向对象程序设计中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof，以及C#的as、is运算符类似，C++提供了dynamic_cast函数用于动态转型。相比C风格的强制类型转换和C++ reinterpret_cast，dynamic_cast提供了类型安全检查，是一种基于能力查询(Capability Query)的转换，所以在多态类型间进行转换更提倡采用dynamic_cast。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>被 <code>volatile</code> 修饰的变量，在对其进行读写操作时，会引发一些<strong>可观测的副作用</strong>。而这些可观测的副作用，是由<strong>程序之外的因素决定的</strong>。</p><h2 id="volatile应用"><a href="#volatile应用" class="headerlink" title="volatile应用"></a>volatile应用</h2><p>（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  *output = (<span class="type">unsigned</span>  <span class="type">int</span> *)<span class="number">0xff800000</span>; <span class="comment">//定义一个IO端口；  </span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;      </span><br><span class="line">    <span class="type">int</span> i;      </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; <span class="number">10</span>;i++)    </span><br><span class="line">    &#123;      </span><br><span class="line">        *output = i;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;      </span><br><span class="line">    *output = <span class="number">9</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p><p>（2）一个中断服务子程序中访问到的变量；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(i) dosomething();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt service routine */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IRS</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。</p><p>（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">bool</span> bStop=<span class="literal">false</span>;  <span class="comment">//bStop 为共享全局变量  </span></span><br><span class="line"><span class="comment">//第一个线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadFunc1</span><span class="params">()</span>&#123;    ...    <span class="keyword">while</span>(!bStop)&#123;...&#125;&#125;</span><br><span class="line"><span class="comment">//第二个线程终止上面的线程循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadFunc2</span><span class="params">()</span>&#123;    ...    bStop = <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure><p>要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p><p>是否了解volatile的应用场景是区分C&#x2F;C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。</p><h2 id="volatile使用"><a href="#volatile使用" class="headerlink" title="volatile使用"></a>volatile使用</h2><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p></li></ul><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>断言，<strong>是宏，而非函数</strong>。</p><p>assert 宏的原型定义在 &lt;assert.h&gt;（C）、（C++）中。其作用是如果它的条件返回错误，则终止程序执行。</p><p>可以通过定义 <code>NDEBUG</code> 来关闭 assert，<strong>但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">(<span class="type">int</span> expression)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;     </span><br><span class="line">    <span class="type">int</span> x = <span class="number">7</span>;     <span class="comment">/*  Some big code in between and let&#x27;s say x  </span></span><br><span class="line"><span class="comment">    is accidentally changed to 9  */</span></span><br><span class="line">    x = <span class="number">9</span>;     <span class="comment">// Programmer assumes x to be 7 in rest of the code </span></span><br><span class="line">    assert(x==<span class="number">7</span>);     <span class="comment">/* Rest of the code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert: assert.c:<span class="number">13</span>: main: Assertion <span class="string">&#x27;x==7&#x27;</span> failed.</span><br></pre></td></tr></table></figure><p>可以看到输出会把源码文件，行号错误位置，提示出来！</p><ul><li>断言主要用于检查逻辑上不可能的情况。</li></ul><blockquote><p>例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。</p></blockquote><ul><li>忽略断言，在代码开头加上：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br></pre></td></tr></table></figure><h1 id="Bit-field"><a href="#Bit-field" class="headerlink" title="Bit field"></a>Bit field</h1><p>“ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。这种数据结构的一个好处是它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。第二个好处是位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。而这种数据结构的缺点在于，位段实现依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h2 id="位域使用"><a href="#位域使用" class="headerlink" title="位域使用"></a>位域使用</h2><p>位域通常使用结构体声明， 该结构声明为每个位域成员设置名称，并决定其宽度：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">bit_field_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">member_name</span> <span class="operator">:</span> width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Elements</th><th>Description</th></tr></thead><tbody><tr><td>bit_field_name</td><td>位域结构名</td></tr><tr><td>type</td><td>位域成员的类型，必须为 int、signed int 或者 unsigned int 类型</td></tr><tr><td>member_name</td><td>位域成员名</td></tr><tr><td>width</td><td>规定成员所占的位数</td></tr></tbody></table><p>例如声明如下一个位域:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_PRCODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> code1: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cdde2: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> code3: <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PRCODE</span> prcode;</span><br></pre></td></tr></table></figure><p>该定义使 <code>prcode</code>包含 2 个 2 Bits 位域和 1 个 8 Bits 位域，我们可以使用结构体的成员运算符对其进行赋值</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">prcode.code1</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">prcode.code2</span> = <span class="number">3</span><span class="comment">;</span></span><br><span class="line"><span class="attr">procde.code3</span> = <span class="number">102</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>赋值时要注意值的大小不能超过位域成员的容量，例如 prcode.code3 为 8 Bits 的位域成员，其容量为 2^8 &#x3D; 256，即赋值范围应为 [0,255]。</p><h2 id="位域的大小和对齐"><a href="#位域的大小和对齐" class="headerlink" title="位域的大小和对齐"></a>位域的大小和对齐</h2><h3 id="位域的大小"><a href="#位域的大小" class="headerlink" title="位域的大小"></a>位域的大小</h3><p>例如以下位域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该位域结构体中间有一个未命名的位域，占据 3 Bits，仅起填充作用，并无实际意义。 填充使得该结构总共使用了 8 Bits。但 C 语言使用 unsigned int 作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同。 有些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。文章以下均默认 unsigned int 为 32 Bits。</p><h3 id="位域的对齐"><a href="#位域的对齐" class="headerlink" title="位域的对齐"></a>位域的对齐</h3><p>一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐。 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field1: <span class="number">30</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field2: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field3: <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>field1</code> + <code>field2</code> &#x3D; 34 Bits，超出 32 Bits, 编译器会将<code>field2</code>移位至下一个 unsigned int 单元存放， stuff.field1 和 stuff.field2 之间会留下一个 2 Bits 的空隙， stuff.field3 紧跟在 stuff.field2 之后，该结构现在大小为 2 * 32 &#x3D; 64 Bits。</p><p>这个空洞可以用之前提到的未命名的位域成员填充，我们也可以使用一个宽度为 0 的未命名位域成员令下一位域成员与下一个整数对齐。 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stuff</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field1: <span class="number">30</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field2: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>       : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> field3: <span class="number">3</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 stuff.field1 与 stuff.field2 之间有一个 2 Bits 的空隙，stuff.field3 则存储在下一个 unsigned int 中，该结构现在大小为 3 * 32 &#x3D; 96 Bits。</p><h2 id="位域的初始化和位的重映射"><a href="#位域的初始化和位的重映射" class="headerlink" title="位域的初始化和位的重映射"></a>位域的初始化和位的重映射</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>位域的初始化与普通结构体初始化的方法相同，这里列举两种，如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> stuff s1= &#123;<span class="number">20</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>或者直接为位域成员赋值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct stuff s1<span class="comment">;</span></span><br><span class="line">s1.field1 <span class="operator">=</span> <span class="number">20</span><span class="comment">;</span></span><br><span class="line">s1.field2 <span class="operator">=</span> <span class="number">8</span><span class="comment">;</span></span><br><span class="line">s1.field3 <span class="operator">=</span> <span class="number">4</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="位域的重映射-Re-mapping"><a href="#位域的重映射-Re-mapping" class="headerlink" title="位域的重映射 (Re-mapping)"></a>位域的重映射 (Re-mapping)</h3><p>声明一个 大小为 32 Bits 的位域</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ready:     <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> error:     <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> command:   <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sector_no: <span class="number">24</span>;</span><br><span class="line">&#125;b1;</span><br></pre></td></tr></table></figure><h4 id="利用重映射将位域归零"><a href="#利用重映射将位域归零" class="headerlink" title="利用重映射将位域归零"></a>利用重映射将位域归零</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* p = (int *) &amp;b1;  <span class="regexp">//</span> 将 <span class="string">&quot;位域结构体的地址&quot;</span> 映射至 <span class="string">&quot;整形（int*) 的地址&quot;</span> </span><br><span class="line">*p = <span class="number">0</span>;                <span class="regexp">//</span> 清除 s1，将各成员归零</span><br></pre></td></tr></table></figure><h4 id="利用联合-union-将-32-Bits-位域-重映射至-unsigned-int-型"><a href="#利用联合-union-将-32-Bits-位域-重映射至-unsigned-int-型" class="headerlink" title="利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型"></a>利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型</h4><p>先简单介绍一下联合</p><blockquote><p>“联合” 是一种特殊的类，也是一种构造类型的数据结构。在一个 “联合” 内可以定义多种不同的数据类型， 一个被说明为该 “联合” 类型的变量中，允许装入该 “联合” 所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的</p><p>“联合” 与 “结构” 有一些相似之处。但两者有本质上的不同。在结构中各成员有各自的内存空间， 一个结构变量的总长度是各成员长度之和（空结构除外，同时不考虑边界调整）。而在 “联合” 中，各成员共享一段内存空间， 一个联合变量的长度等于各成员中最长的长度。应该说明的是， 这里所谓的共享不是指把多个成员同时装入一个联合变量内， 而是指该联合变量可被赋予任一成员值，但每次只能赋一种值， 赋入新值则冲去旧值。</p></blockquote><p>我们可以声明以下联合:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">u_box</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">box</span> st_box;     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ui_box;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>x86 系统中 unsigned int 和 box 都为 32 Bits, 通过该联合使 st_box 和 ui_box 共享一块内存。具体位域中哪一位与 unsigned int 哪一位相对应，取决于编译器和硬件。 利用联合将位域归零，代码如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union u_box u<span class="comment">;</span></span><br><span class="line">u.ui_box <span class="operator">=</span> <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><h2 id="1-C-与C编译区别"><a href="#1-C-与C编译区别" class="headerlink" title="1.C++与C编译区别"></a>1.C++与C编译区别</h2><p>在C++中常在头文件见到extern “C”修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。</p><p>C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。</p><p>例如<code>int add(int a, int b)</code>函数经过C++编译器生成.o文件后，<code>add</code>会变成形如<code>add_int_int</code>之类的, 而C的话则会是形如<code>_add</code>, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。</p><p>这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时<code>extern &quot;C&quot;</code>就起作用了：告诉链接器去寻找<code>_add</code>这类的C语言符号，而不是经过C++修饰的符号。</p><h2 id="2-C-调用C函数"><a href="#2-C-调用C函数" class="headerlink" title="2.C++调用C函数"></a>2.C++调用C函数</h2><p>C++调用C函数的例子: 引用C的头文件时，需要加<code>extern &quot;C&quot;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;    <span class="keyword">return</span> x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Generate <span class="keyword">add</span>.o file</span><br><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>链接：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="keyword">add</span>.cpp <span class="keyword">add</span>.o -o main</span><br></pre></td></tr></table></figure><p>没有添加extern “C” 报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; g++ add.cpp add.o -o main                                   add.o：在函数‘main’中：add.cpp:(.text+<span class="number">0x0</span>): `main<span class="number">&#x27;</span>被多次定义</span><br><span class="line">/tmp/ccH65yQF.o:add.cpp:(.text+<span class="number">0x0</span>)：第一次在此定义</span><br><span class="line">/tmp/ccH65yQF.o：在函数‘main’中：</span><br><span class="line">add.cpp:(.text+<span class="number">0xf</span>)：对‘add(<span class="type">int</span>, <span class="type">int</span>)’未定义的引用</span><br><span class="line">add.o：在函数‘main’中：</span><br><span class="line">add.cpp:(.text+<span class="number">0xf</span>)：对‘add(<span class="type">int</span>, <span class="type">int</span>)’未定义的引用</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><p>添加extern “C”后：</p><p><code>add.cpp</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候一定要注意，先通过gcc生成中间文件add.o。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> <span class="keyword">add</span>.<span class="keyword">c</span> </span><br></pre></td></tr></table></figure><p>然后编译：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="keyword">add</span>.cpp <span class="keyword">add</span>.o -o main</span><br></pre></td></tr></table></figure><p>而通常为了C代码能够通用，即既能被C调用，又能被C++调用，头文件通常会有如下写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>即在C++调用该接口时，会以C接口的方式调用。这种方式使得C++者不需要额外的extern C，而标准库头文件通常也是类似的做法，否则你为何不需要extern C就可以直接使用stdio.h中的C函数呢？</p><h2 id="3-C中调用C-函数"><a href="#3-C中调用C-函数" class="headerlink" title="3.C中调用C++函数"></a>3.C中调用C++函数</h2><p><code>extern &quot;C&quot;</code>在C中是语法错误，需要放在C++头文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;    <span class="keyword">return</span> x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    add(<span class="number">2</span>,<span class="number">3</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c add.cpp</span><br></pre></td></tr></table></figure><p>链接：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">add</span>.<span class="keyword">c</span> <span class="keyword">add</span>.o -o main</span><br></pre></td></tr></table></figure><p>综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p><p>总结出如下形式：</p><p>（1）C++调用C函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）C调用C++函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;    <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;    &#125;</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>不过与C++调用C接口不同，C++确实是能够调用编译好的C函数，而这里C调用C++，不过是把C++代码当成C代码编译后调用而已。也就是说，C并不能直接调用C++库函数。</p><h1 id="C和C-中struct"><a href="#C和C-中struct" class="headerlink" title="C和C++中struct"></a>C和C++中struct</h1><h2 id="1-C中struct"><a href="#1-C中struct" class="headerlink" title="1.C中struct"></a>1.C中struct</h2><ul><li>在C中struct只单纯的用作数据的复合类型，也就是说，在结构体声明中只能将数据成员放在里面，而不能将函数放在里面。</li><li>在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用。</li><li>在C中定义结构体变量，如果使用了下面定义必须加struct。</li><li>C的结构体不能继承（没有这一概念）。</li><li>若结构体的名字与函数名相同，可以正常运行且正常的调用！例如：可以定义与 struct Base 不冲突的 void Base() {}。</li></ul><p>完整案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>            <span class="comment">// public</span></span><br><span class="line">    <span class="type">int</span> v1; </span><br><span class="line"><span class="comment">//    public:      //error</span></span><br><span class="line">        <span class="type">int</span> v2;     <span class="comment">//private:</span></span><br><span class="line">        <span class="type">int</span> v3;     <span class="comment">//void print()&#123;       // c中不能在结构体中嵌入函数</span></span><br><span class="line">    <span class="comment">//    printf(&quot;%s\n&quot;,&quot;hello world&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;;    //error!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Base</span><span class="params">()</span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;I am Base func&quot;</span>);&#125;</span><br><span class="line"><span class="comment">//struct Base base1;  //ok</span></span><br><span class="line"><span class="comment">//Base base2; //error</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">base</span>;</span>    </span><br><span class="line">    base.v1=<span class="number">1</span>;    <span class="comment">//base.print();</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v1);    </span><br><span class="line">    Base();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">I am Base <span class="keyword">func</span></span><br></pre></td></tr></table></figure><h2 id="2-C-中struct"><a href="#2-C-中struct" class="headerlink" title="2.C++中struct"></a>2.C++中struct</h2><p>与C对比如下：</p><ul><li>C++结构体中不仅可以定义数据，还可以定义函数。</li><li>C++结构体中可以使用访问修饰符，如：public、protected、private 。</li><li>C++结构体使用可以直接使用不带struct。</li><li>C++继承</li><li>若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只能用带struct的！</li></ul><p>例如：</p><blockquote><p>情形1：不适用typedef定义结构体别名</p></blockquote><p>未添加同名函数前：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>    &#125;;</span><br><span class="line"><span class="comment">//Student()&#123;&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span> <span class="comment">//ok</span></span><br><span class="line">Student s;  <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>添加同名函数后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>    &#125;;</span><br><span class="line">Student()&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span> <span class="comment">//ok</span></span><br><span class="line">Student s;  <span class="comment">//error</span></span><br></pre></td></tr></table></figure><blockquote><p>情形二：使用typedef定义结构体别名</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> </span></span><br><span class="line"><span class="class">&#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;    </span><br><span class="line">    <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">    <span class="type">int</span> v2;    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>); &#125;;    </span><br><span class="line">&#125;B;</span><br><span class="line"><span class="comment">//void B() &#123;&#125;  //error! 符号 &quot;B&quot; 已经被定义为一个 &quot;struct Base1&quot; 的别名</span></span><br></pre></td></tr></table></figure><blockquote><p>前三种案例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;    </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);   &#125;;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">base1</span>;</span>  <span class="comment">//ok</span></span><br><span class="line">    Base base2; <span class="comment">//ok</span></span><br><span class="line">    Base base;    </span><br><span class="line">    base.v1=<span class="number">1</span>;    </span><br><span class="line">    base.v3=<span class="number">2</span>;    </span><br><span class="line">    base.print();    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v1);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v3);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承案例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:   <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;    </span><br><span class="line">        virtual <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Base&quot;</span>);  &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span>:</span>Base &#123;             </span><br><span class="line">public:</span><br><span class="line">        <span class="type">int</span> v2;    </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Derived&quot;</span>);  &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    Base *b=new Derived();    </span><br><span class="line">    b-&gt;print();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同名函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>             </span><br><span class="line">    <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;   </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);  &#125;;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span>             </span><br><span class="line">        <span class="type">int</span> v1;</span><br><span class="line"><span class="comment">//    private:   //error!</span></span><br><span class="line">        <span class="type">int</span> v3;    </span><br><span class="line">public:     <span class="comment">//显示声明public</span></span><br><span class="line">        <span class="type">int</span> v2;   </span><br><span class="line">        <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);   &#125;;    </span><br><span class="line">&#125;B;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Base</span><span class="params">()</span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;I am Base func&quot;</span>);&#125;</span><br><span class="line"><span class="comment">//void B() &#123;&#125;  //error! 符号 &quot;B&quot; 已经被定义为一个 &quot;struct Base1&quot; 的别名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="title">base</span>;</span>  <span class="comment">//ok</span></span><br><span class="line">    <span class="comment">//Base base1;  // error!</span></span><br><span class="line">    base.v1=<span class="number">1</span>;    </span><br><span class="line">    base.v3=<span class="number">2</span>;    </span><br><span class="line">    base.print();    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v1);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,base.v3);    </span><br><span class="line">    Base();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><h3 id="C和C-中的Struct区别"><a href="#C和C-中的Struct区别" class="headerlink" title="C和C++中的Struct区别"></a>C和C++中的Struct区别</h3><table><thead><tr><th>C</th><th>C++</th></tr></thead><tbody><tr><td>不能将函数放在结构体声明</td><td>能将函数放在结构体声明</td></tr><tr><td>在C结构体声明中不能使用C++访问修饰符。</td><td>public、protected、private 在C++中可以使用。</td></tr><tr><td>在C中定义结构体变量，如果使用了下面定义必须加struct。</td><td>可以不加struct</td></tr><tr><td>结构体不能继承（没有这一概念）。</td><td>可以继承</td></tr><tr><td>若结构体的名字与函数名相同，可以正常运行且正常的调用！</td><td>若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！</td></tr></tbody></table><h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><h1 id="C实现C-的面向对象特性"><a href="#C实现C-的面向对象特性" class="headerlink" title="C实现C++的面向对象特性"></a>C实现C++的面向对象特性</h1><p>C++中的多态:在C++中会维护一张虚函数表，根据赋值兼容规则，我们知道父类的指针或者引用是可以指向子类对象的。</p><p>如果一个父类的指针或者引用调用父类的虚函数则该父类的指针会在自己的虚函数表中查找自己的函数地址，如果该父类对象的指针或者引用指向的是子类的对象，而且该子类已经重写了父类的虚函数，则该指针会调用子类的已经重写的虚函数。</p><ul><li>封装</li></ul><p>C语言中是没有class类这个概念的，但是有struct结构体，我们可以考虑使用struct来模拟；</p><p>使用函数指针把属性与方法封装到结构体中。</p><ul><li>继承</li></ul><p>结构体嵌套</p><ul><li>多态</li></ul><p>类与子类方法的函数指针不同</p><p>在C语言的结构体内部是没有成员函数的，如果实现这个父结构体和子结构体共有的函数呢？我们可以考虑使用函数指针来模拟。但是这样处理存在一个缺陷就是：父子各自的函数指针之间指向的不是类似C++中维护的虚函数表而是一块物理内存，如果模拟的函数过多的话就会不容易维护了。</p><p>模拟多态，必须保持函数指针变量对齐(在内容上完全一致，而且变量对齐上也完全一致)。否则父类指针指向子类对象，运行崩溃！</p><h1 id="explicit-显式-关键字"><a href="#explicit-显式-关键字" class="headerlink" title="explicit(显式)关键字"></a>explicit(显式)关键字</h1><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外</li></ul><h1 id="友元函数与友元类"><a href="#友元函数与友元类" class="headerlink" title="友元函数与友元类"></a>友元函数与友元类</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><p>友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员的机制。也就是说有两种形式的友元：</p><p>（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。</p><p>（2）友元类：类A中的成员函数访问类B中的私有或保护成员</p><p>优点：提高了程序的运行效率。</p><p>缺点：破坏了类的封装性和数据的透明性。</p><p>总结：</p><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h2 id="1-友元函数"><a href="#1-友元函数" class="headerlink" title="1.友元函数"></a>1.友元函数</h2><p>在类声明的任何区域中声明，而定义则在类的外部。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend <span class="tag">&lt;<span class="name">类型</span>&gt;</span><span class="tag">&lt;<span class="name">友元函数名</span>&gt;</span>(<span class="tag">&lt;<span class="name">参数表</span>&gt;</span>);</span><br></pre></td></tr></table></figure><p>注意，友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> _a):a(_a)&#123;&#125;;    </span><br><span class="line">    friend <span class="type">int</span> <span class="title function_">geta</span><span class="params">(A &amp;ca)</span>;  <span class="comment">///&lt; 友元函数</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">geta</span><span class="params">(A &amp;ca)</span> &#123;    <span class="keyword">return</span> ca.a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    A <span class="title function_">a</span><span class="params">(<span class="number">3</span>)</span>;        </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;geta(a)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-友元类"><a href="#2-友元类" class="headerlink" title="2.友元类"></a>2.友元类</h2><p>友元类的声明在该类的声明中，而实现在该类外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> &lt;友元类名&gt;;</span><br></pre></td></tr></table></figure><p>类B是类A的友元，那么类B可以直接访问A的私有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> _a):a(_a)&#123;&#125;;    </span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getb</span><span class="params">(A ca)</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span>  ca.a;     </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    A <span class="title function_">a</span><span class="params">(<span class="number">3</span>)</span>;    </span><br><span class="line">    B b;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.getb(a)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h2><ul><li><p>友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。</p></li><li><p>友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。</p></li></ul><h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>局部与全局using，具体操作与使用见下面案例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isNs1 1</span></span><br><span class="line"><span class="comment">//#define isGlobal 2</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;::func&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace ns1 &#123;    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ns1::func&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace ns2 </span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> isNs1     </span></span><br><span class="line">    using ns1::func;    <span class="comment">/// ns1中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> isGlobal    </span></span><br><span class="line">    using ::func; <span class="comment">/// 全局中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>     </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;other::func&quot;</span>&lt;&lt;<span class="built_in">endl</span>;     </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这就是为什么在c++中使用了cmath而不是math.h头文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ns2::func(); <span class="comment">// 会根据当前环境定义宏的不同来调用不同命名空间下的func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改变访问性"><a href="#改变访问性" class="headerlink" title="改变访问性"></a>改变访问性</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n;  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类Derived私有继承了Base，对于它来说成员变量n和成员函数size都是私有的，如果使用了using语句，可以改变他们的可访问性，如上述例子中，size可以按public的权限访问，n可以按protected的权限访问。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。</p><p>如果对于基类的重载函数，我们需要在派生类中修改一个，又要让其他的保持可见，必须要重载所有版本，这样十分的繁琐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>    </span><br><span class="line">public:</span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;        </span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::f(int)&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> private Base </span><br><span class="line">&#123;    public:</span><br><span class="line">        using Base::f;        </span><br><span class="line">        <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Derived::f(int)&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    Base b;    </span><br><span class="line">    Derived d;    </span><br><span class="line">    d.f();    </span><br><span class="line">    d.f(<span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，在派生类中使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。</p><h2 id="取代typedef"><a href="#取代typedef" class="headerlink" title="取代typedef"></a>取代typedef</h2><p>C中常用typedef A B这样的语法，将B定义为A类型，也就是给A类型一个别名B</p><p>对应typedef A B，使用using B&#x3D;A可以进行同样的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; V1; </span><br><span class="line">using V2 = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h1 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h1><ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul><h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><h2 id="传统行为"><a href="#传统行为" class="headerlink" title="传统行为"></a>传统行为</h2><p>枚举有如下问题：</p><ul><li>作用域不受限,会容易引起命名冲突。例如下面无法编译通过的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span>RED,BLUE&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Feeling</span> &#123;</span>EXCITED,BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>会隐式转换为int</li><li>用来表征枚举变量的实际类型不能明确指定，从而无法支持枚举类型的前向声明。</li></ul><h2 id="经典做法"><a href="#经典做法" class="headerlink" title="经典做法"></a>经典做法</h2><p>解决作用域不受限带来的命名冲突问题的一个简单方法是，给枚举变量命名时加前缀，如上面例子改成 COLOR_BLUE 以及 FEELING_BLUE。</p><p>一般说来，为了一致性我们会把所有常量统一加上前缀。但是这样定义枚举变量的代码就显得累赘。C 程序中可能不得不这样做。不过 C++ 程序员恐怕都不喜欢这种方法。替代方案是命名空间:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace Color &#123;    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span>    </span></span><br><span class="line"><span class="class">    &#123;</span>        </span><br><span class="line">        RED=<span class="number">15</span>,        </span><br><span class="line">        YELLOW,       </span><br><span class="line">        BLUE    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样之后就可以用 <code>Color::Type c = Color::RED;</code> 来定义新的枚举变量了。如果 <code>using namespace Color</code> 后，前缀还可以省去，使得代码简化。不过，因为命名空间是可以随后被扩充内容的，所以它提供的作用域封闭性不高。在大项目中，还是有可能不同人给不同的东西起同样的枚举类型名。</p><p>更“有效”的办法是用一个类或结构体来限定其作用域，例如：定义新变量的方法和上面命名空间的相同。不过这样就不用担心类在别处被修改内容。这里用结构体而非类，是因为本身希望这些常量可以公开访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color1</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span>   </span></span><br><span class="line"><span class="class">    &#123;</span>        </span><br><span class="line">        RED=<span class="number">102</span>,        </span><br><span class="line">        YELLOW,        </span><br><span class="line">        BLUE    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="C-11-的枚举类"><a href="#C-11-的枚举类" class="headerlink" title="C++11 的枚举类"></a>C++11 的枚举类</h2><p>上面的做法解决了第一个问题，但对于后两个仍无能为力。庆幸的是，C++11 标准中引入了“枚举类”(enum class)，可以较好地解决上述问题。</p><ul><li>新的enum的作用域不在是全局的</li><li>不能隐式转换成其他类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief C++11的枚举类</span></span><br><span class="line"><span class="comment"> * 下面等价于enum class Color2:int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color2</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    RED=<span class="number">2</span>,    </span><br><span class="line">    YELLOW,    </span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line">r2 c2 = Color2::RED;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; static_cast&lt;<span class="type">int</span>&gt;(c2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//必须转！</span></span><br></pre></td></tr></table></figure><ul><li>可以指定用特定的类型来存储enum</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color3</span>:</span><span class="type">char</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color3</span>:</span><span class="type">char</span> &#123;    RED=<span class="string">&#x27;r&#x27;</span>,    BLUE&#125;;</span><br><span class="line"><span class="type">char</span> c3 = static_cast&lt;<span class="type">char</span>&gt;(Color3::RED);</span><br></pre></td></tr></table></figure><h2 id="类中的枚举类型"><a href="#类中的枚举类型" class="headerlink" title="类中的枚举类型"></a>类中的枚举类型</h2><p>有时我们希望某些常量只在类中有效。 由于#define 定义的宏常量是全局的，不能达到目的，于是想到实用const 修饰数据成员来实现。而const 数据成员的确是存在的，但其含义却不是我们所期望的。</p><p>const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。</p><p>不能在类声明中初始化 const 数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道 SIZE 的值是什么。(c++11标准前)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;   <span class="comment">// 错误，企图在类声明中初始化 const 数据成员 </span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">array</span>[SIZE];  <span class="comment">// 错误，未知的 SIZE </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>正确应该在类的构造函数的初始化列表中进行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  A(<span class="type">int</span> size);  <span class="comment">// 构造函数 </span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> SIZE ;    &#125;; </span><br><span class="line">A::A(<span class="type">int</span> size) : SIZE(size)  <span class="comment">// 构造函数的定义</span></span><br><span class="line">&#123; &#125; A  <span class="title function_">a</span><span class="params">(<span class="number">100</span>)</span>; <span class="comment">// 对象 a 的 SIZE 值为 100 </span></span><br><span class="line">A  <span class="title function_">b</span><span class="params">(<span class="number">200</span>)</span>; <span class="comment">// 对象 b 的 SIZE 值为 200 </span></span><br></pre></td></tr></table></figure><p>怎样才能建立在整个类中都恒定的常量呢？</p><p>别指望 const 数据成员了，应该用类中的枚举常量来实现。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>        BOY = <span class="number">0</span>,        GIRL    &#125;SexType;&#125;;</span><br><span class="line"><span class="comment">//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。</span></span><br></pre></td></tr></table></figure><p>枚举常量不会占用对象的存储空间，它们在编译时被全部求值。</p><p>枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点。</p><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>decltype的语法是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (expression)</span><br></pre></td></tr></table></figure><p>这里的括号是必不可少的,decltype的作用是“查询表达式的类型”，因此，上面语句的效果是，返回 expression 表达式的类型。注意，decltype 仅仅“查询”表达式的类型，并不会对表达式进行“求值”。</p><h3 id="1-1-推导出表达式类型"><a href="#1-1-推导出表达式类型" class="headerlink" title="1.1 推导出表达式类型"></a>1.1 推导出表达式类型</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">decltype(i) a; <span class="regexp">//</span>推导结果为<span class="keyword">int</span>。a的类型为<span class="keyword">int</span>。</span><br></pre></td></tr></table></figure><h3 id="1-2-与using-x2F-typedef合用，用于定义类型。"><a href="#1-2-与using-x2F-typedef合用，用于定义类型。" class="headerlink" title="1.2 与using&#x2F;typedef合用，用于定义类型。"></a>1.2 与using&#x2F;typedef合用，用于定义类型。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using <span class="type">size_t</span> = decltype(<span class="keyword">sizeof</span>(<span class="number">0</span>));<span class="comment">//sizeof(a)的返回值为size_t类型</span></span><br><span class="line">using <span class="type">ptrdiff_t</span> = decltype((<span class="type">int</span>*)<span class="number">0</span> - (<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">using <span class="type">nullptr_t</span> = decltype(nullptr);<span class="built_in">vector</span>&lt;<span class="type">int</span> &gt;vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">decltype</span><span class="params">(vec.begin())</span> vectype;</span><br><span class="line"><span class="keyword">for</span> (vectype i = vec.begin; i != vec.end(); i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样和auto一样，也提高了代码的可读性。</p><h3 id="1-3-重用匿名类型"><a href="#1-3-重用匿名类型" class="headerlink" title="1.3 重用匿名类型"></a>1.3 重用匿名类型</h3><p>在C++中，我们有时候会遇上一些匿名类型，如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="type">int</span> d ;    <span class="type">double</span> b;&#125;anon_s;</span><br></pre></td></tr></table></figure><p>而借助decltype，我们可以重新使用这个匿名的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(anon_s) as ;<span class="comment">//定义了一个上面匿名的结构体</span></span><br></pre></td></tr></table></figure><h3 id="1-4-泛型编程中结合auto，用于追踪函数的返回值类型"><a href="#1-4-泛型编程中结合auto，用于追踪函数的返回值类型" class="headerlink" title="1.4 泛型编程中结合auto，用于追踪函数的返回值类型"></a>1.4 泛型编程中结合auto，用于追踪函数的返回值类型</h3><p>这也是decltype最大的用途了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">multiply</span><span class="params">(T x, T y)</span>-&gt;<span class="title function_">decltype</span><span class="params">(x*y)</span>&#123;    <span class="keyword">return</span> x*y;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-判别规则"><a href="#2-判别规则" class="headerlink" title="2.判别规则"></a>2.判别规则</h2><p>对于decltype(e)而言，其判别结果受以下条件的影响：</p><p>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&amp;&amp; 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&amp;。 否则，假设e的类型是T，则decltype（e）为T。</p><p>标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>则arr为一个标记符表达式，而arr[3]+0不是。</p><p>举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span> <span class="type">double</span> d; &#125;s ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Overloaded</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Overloaded</span><span class="params">(<span class="type">char</span>)</span>;<span class="comment">//重载的函数</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; <span class="title function_">RvalRef</span><span class="params">()</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> <span class="title function_">Func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：推导为其类型</span></span><br><span class="line">decltype (arr) var1; <span class="comment">//int[] 标记符表达式</span></span><br><span class="line"></span><br><span class="line">decltype (ptr) var2;<span class="comment">//int *  标记符表达式</span></span><br><span class="line"></span><br><span class="line">decltype(s.d) var3;<span class="comment">//doubel 成员访问表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(Overloaded) var4;//重载函数。编译错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则二：将亡值。推导为类型的右值引用。</span></span><br><span class="line"></span><br><span class="line">decltype (RvalRef()) var5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则三：左值，推导为类型的引用。</span></span><br><span class="line"></span><br><span class="line">decltype ((i))var6 = i;     <span class="comment">//int&amp;</span></span><br><span class="line"></span><br><span class="line">decltype (<span class="literal">true</span> ? i : i) var7 = i; <span class="comment">//int&amp;  条件表达式返回左值。</span></span><br><span class="line"></span><br><span class="line">decltype (++i) var8 = i; <span class="comment">//int&amp;  ++i返回i的左值。</span></span><br><span class="line"></span><br><span class="line">decltype(arr[<span class="number">5</span>]) var9 = i;<span class="comment">//int&amp;. []操作返回左值</span></span><br><span class="line"></span><br><span class="line">decltype(*ptr)var10 = i;<span class="comment">//int&amp; *操作返回左值</span></span><br><span class="line"></span><br><span class="line">decltype(<span class="string">&quot;hello&quot;</span>)var11 = <span class="string">&quot;hello&quot;</span>; <span class="comment">//const char(&amp;)[9]  字符串字面常量为左值，且为const左值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则四：以上都不是，则推导为本类型</span></span><br><span class="line"></span><br><span class="line">decltype(<span class="number">1</span>) var12;<span class="comment">//const int</span></span><br><span class="line"></span><br><span class="line">decltype(Func(<span class="number">1</span>)) var13=<span class="literal">true</span>;<span class="comment">//const bool</span></span><br><span class="line"></span><br><span class="line">decltype(i++) var14 = i;<span class="comment">//int i++返回右值</span></span><br></pre></td></tr></table></figure><h1 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h1><h2 id="1-引用与指针"><a href="#1-引用与指针" class="headerlink" title="1.引用与指针"></a>1.引用与指针</h2><p>总论：</p><table><thead><tr><th>引用</th><th>指针</th></tr></thead><tbody><tr><td>必须初始化</td><td>可以不初始化</td></tr><tr><td>不能为空</td><td>可以为空</td></tr><tr><td>不能更换目标</td><td>可以更换目标</td></tr></tbody></table><blockquote><p>引用必须初始化，而指针可以不初始化。</p></blockquote><p>我们在定义一个引用的时候必须为其指定一个初始值，但是指针却不需要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;r;    <span class="comment">//不合法，没有初始化引用</span></span><br><span class="line"><span class="type">int</span> *p;    <span class="comment">//合法，但p为野指针，使用需要小心</span></span><br></pre></td></tr></table></figure><blockquote><p>引用不能为空，而指针可以为空。</p></blockquote><p>由于引用不能为空，所以我们在使用引用的时候不需要测试其合法性，而在使用指针的时候需要首先判断指针是否为空指针，否则可能会引起程序崩溃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_p</span><span class="params">(<span class="type">int</span>* p)</span></span><br><span class="line">&#123;      </span><br><span class="line">    <span class="keyword">if</span>(p != null_ptr)    <span class="comment">//对p所指对象赋值时需先判断p是否为空指针</span></span><br><span class="line">        *p = <span class="number">3</span>;    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test_r</span><span class="params">(<span class="type">int</span>&amp; r)</span></span><br><span class="line">&#123;    </span><br><span class="line">    r = <span class="number">3</span>;    <span class="comment">//由于引用不能为空，所以此处无需判断r的有效性就可以对r直接赋值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用不能更换目标</p></blockquote><p>指针可以随时改变指向，但是引用只能指向初始化时指向的对象，无法改变。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> &amp;r = a;    <span class="comment">//初始化引用r指向变量a</span></span><br><span class="line"><span class="built_in">int</span> *p = &amp;a;   <span class="comment">//初始化指针p指向变量a</span></span><br><span class="line"></span><br><span class="line">p = &amp;b;        <span class="comment">//指针p指向了变量b</span></span><br><span class="line">r = b;         <span class="comment">//引用r依然指向a，但a的值变成了b</span></span><br></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><p>C++的引用<strong>在减少了程序员自由度的同时提升了内存操作的安全性和语义的优美性</strong>。比如引用强制要求必须初始化，可以让我们在使用引用的时候不用再去判断引用是否为空，让代码更加简洁优美，避免了指针满天飞的情形。除了这种场景之外引用还用于如下两个场景：</p><blockquote><p>引用型参数</p></blockquote><p>一般我们使用const reference参数作为只读形参，这种情况下既可以避免参数拷贝还可以获得与传值参数一样的调用方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;data)</span>&#123;    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;      <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; data&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;    test(data);&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用型返回值</p></blockquote><p>C++提供了重载运算符的功能，我们在重载某些操作符的时候，使用引用型返回值可以获得跟该操作符原来语法相同的调用方式，保持了操作符语义的一致性。一个例子就是operator []操作符，这个操作符一般需要返回一个引用对象，才能正确的被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(<span class="number">10</span>)</span>;v[<span class="number">5</span>] = <span class="number">10</span>;    <span class="comment">//[]操作符返回引用，然后vector对应元素才能被修改</span></span><br><span class="line">              <span class="comment">//如果[]操作符不返回引用而是指针的话，赋值语句则需要这样写</span></span><br><span class="line">*v[<span class="number">5</span>] = <span class="number">10</span>;   <span class="comment">//这种书写方式，完全不符合我们对[]调用的认知，容易产生误解</span></span><br></pre></td></tr></table></figure><h2 id="3-指针与引用的性能差距"><a href="#3-指针与引用的性能差距" class="headerlink" title="3.指针与引用的性能差距"></a>3.指针与引用的性能差距</h2><p>指针与引用之间有没有性能差距呢？这种问题就需要进入汇编层面去看一下。我们先写一个test1函数，参数传递使用指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span>* p)</span></span><br><span class="line">&#123;    </span><br><span class="line">    *p = <span class="number">3</span>;    <span class="comment">//此处应该首先判断p是否为空，为了测试的需要，此处我们没加。</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码段对应的汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble Dump of assembler code <span class="keyword">for</span> function <span class="title function_">test1</span><span class="params">(<span class="type">int</span>*)</span>:   0x0000000000400886 &lt;+0&gt;:  push   %rbp   0x0000000000400887 &lt;+1&gt;:  mov    %rsp,%rbp   0x000000000040088a &lt;+4&gt;:  mov    %rdi,-0<span class="title function_">x8</span><span class="params">(%rbp)</span>=&gt; <span class="number">0x000000000040088e</span> &lt;+<span class="number">8</span>&gt;:  mov    <span class="number">-0x8</span>(%rbp),%rax   <span class="number">0x0000000000400892</span> &lt;+<span class="number">12</span>&gt;: movl   $<span class="number">0x3</span>,(%rax)   <span class="number">0x0000000000400898</span> &lt;+<span class="number">18</span>&gt;: nop   <span class="number">0x0000000000400899</span> &lt;+<span class="number">19</span>&gt;: pop    %rbp   <span class="number">0x000000000040089a</span> &lt;+<span class="number">20</span>&gt;: retq   End of assembler dump.</span><br></pre></td></tr></table></figure><p>上述代码1、2行是参数调用保存现场操作；第3行是参数传递，函数调用第一个参数一般放在rdi寄存器，此行代码把rdi寄存器值（指针p的值）写入栈中；第4行是把栈中p的值写入rax寄存器；第5行是把立即数3写入到<strong>rax寄存器值所指向的内存</strong>中，此处要注意(%rax)两边的括号，这个括号并并不是可有可无的，(%rax)和%rax完全是两种意义，(%rax)代表rax寄存器中值所代表地址部分的内存，即相当于C++代码中的*p，而%rax代表rax寄存器，相当于C++代码中的p值，所以汇编这里使用了(%rax)而不是%rax。</p><p>我们再写出参数传递使用引用的C++代码段test2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>&amp; r)</span></span><br><span class="line">&#123;    </span><br><span class="line">    r = <span class="number">3</span>;    <span class="comment">//赋值前无需判断reference是否为空</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码对应的汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble Dump of assembler code <span class="keyword">for</span> function <span class="title function_">test2</span><span class="params">(<span class="type">int</span>&amp;)</span>:   0x000000000040089b &lt;+0&gt;:  push   %rbp   0x000000000040089c &lt;+1&gt;:  mov    %rsp,%rbp   0x000000000040089f &lt;+4&gt;:  mov    %rdi,-0<span class="title function_">x8</span><span class="params">(%rbp)</span>=&gt; <span class="number">0x00000000004008a3</span> &lt;+<span class="number">8</span>&gt;:  mov    <span class="number">-0x8</span>(%rbp),%rax   <span class="number">0x00000000004008a7</span> &lt;+<span class="number">12</span>&gt;: movl   $<span class="number">0x3</span>,(%rax)   <span class="number">0x00000000004008ad</span> &lt;+<span class="number">18</span>&gt;: nop   <span class="number">0x00000000004008ae</span> &lt;+<span class="number">19</span>&gt;: pop    %rbp   <span class="number">0x00000000004008af</span> &lt;+<span class="number">20</span>&gt;: retq   End of assembler dump.</span><br></pre></td></tr></table></figure><p>我们发现test2对应的汇编代码和test1对应的汇编代码完全相同，这说明C++编译器在编译程序的时候将指针和引用编译成了完全一样的机器码。所以C++中的引用只是C++对指针操作的一个“语法糖”，在底层实现时C++编译器实现这两种操作的方法完全相同。</p><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h2><p>C++中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，指针与引用底层实现都是一样的，不用担心两者的性能差距。</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="1-宏中包含特殊符号"><a href="#1-宏中包含特殊符号" class="headerlink" title="1.宏中包含特殊符号"></a>1.宏中包含特殊符号</h2><p>分为几种：<code>#</code>，<code>##</code>，<code>\</code></p><h3 id="1-1-字符串化操作符（-）"><a href="#1-1-字符串化操作符（-）" class="headerlink" title="1.1 字符串化操作符（#）"></a>1.1 字符串化操作符（#）</h3><p><strong>在一个宏中的参数前面使用一个#,预处理器会把这个参数转换为一个字符数组</strong>，换言之就是：**#是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串**。</p><p><strong>注意：其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</strong></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> exp(s) printf(<span class="string">&quot;test s is:%s\n&quot;</span>,s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp1(s) printf(<span class="string">&quot;test s is:%s\n&quot;</span>,#s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp2(s) #s </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="built_in">exp</span>(<span class="string">&quot;hello&quot;</span>);    </span><br><span class="line">    exp1(hello);    </span><br><span class="line">    <span class="built_in">string</span> str = exp2(   bac );    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略传入参数名前面和后面的空格。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">string</span> str1 = exp2( asda  bac );    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当传入参数名间存在空格时，编译器将会自动连接各个子字符串，</span></span><br><span class="line"><span class="comment">     * 用每个子字符串之间以一个空格连接，忽略剩余空格。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str1.size()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码给出了基本的使用与空格处理规则，空格处理规则如下：</p><ul><li>忽略传入参数名前面和后面的空格。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = exp2(   bac );</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bac</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = exp2( asda  bac );</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str1.size()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">asda</span> bac <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="1-2-符号连接操作符（-）"><a href="#1-2-符号连接操作符（-）" class="headerlink" title="1.2 符号连接操作符（##）"></a>1.2 符号连接操作符（##）</h3><p><strong>“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。将宏定义的多个形参转换成一个实际参数名。</strong></p><p>注意事项：</p><p><strong>（1）当用##连接形参时，##前后的空格可有可无。</strong></p><p><strong>（2）连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。</strong></p><p><strong>（3）如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> expA(s) printf(<span class="string">&quot;前缀加上后的字符串为:%s\n&quot;</span>,gc_##s)  <span class="comment">//gc_s必须存在</span></span></span><br><span class="line"><span class="comment">// 注意事项2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> expB(s) printf(<span class="string">&quot;前缀加上后的字符串为:%s\n&quot;</span>,gc_  ##  s)  <span class="comment">//gc_s必须存在</span></span></span><br><span class="line"><span class="comment">// 注意事项1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc_hello1 <span class="string">&quot;I am gc_hello1&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;    <span class="comment">// 注意事项1</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * gc_hello = <span class="string">&quot;I am gc_hello&quot;</span>;    </span><br><span class="line">    expA(hello);    </span><br><span class="line">    expB(hello1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-续行操作符（-）"><a href="#1-3-续行操作符（-）" class="headerlink" title="1.3 续行操作符（\）"></a>1.3 续行操作符（\）</h3><p><strong>当定义的宏不能用一行表达完整时，可以用”\”表示下一行继续此宏的定义。</strong></p><p><strong>注意 \ 前留空格。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a)&gt;(b) ? (a) \   :(b))  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> max_val = MAX(<span class="number">3</span>,<span class="number">6</span>);    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max_val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-do-…-while-0-的使用"><a href="#2-do-…-while-0-的使用" class="headerlink" title="2.do{…}while(0)的使用"></a>2.do{…}while(0)的使用</h2><h3 id="2-1-避免语义曲解"><a href="#2-1-避免语义曲解" class="headerlink" title="2.1 避免语义曲解"></a>2.1 避免语义曲解</h3><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="function"><span class="title">fun</span><span class="params">()</span></span> f1();f2();</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这个宏被展开后就是：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    <span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure><p>本意是a&gt;0执行f1 f2，而实际是f2每次都会执行，所以就错误了。</p><p>为了解决这种问题，在写代码的时候，通常可以采用<code>&#123;&#125;</code>块。</p><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fun() &#123;f1();f2();&#125;</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)    fun();</span><br><span class="line"><span class="comment">// 宏展开</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;    f1();    f2();&#125;;</span><br></pre></td></tr></table></figure><p>但是会发现上述宏展开后多了一个分号，实际语法不太对。(虽然编译运行没问题，正常没分号)。</p><h3 id="2-2避免使用goto控制流"><a href="#2-2避免使用goto控制流" class="headerlink" title="2.2避免使用goto控制流"></a>2.2避免使用goto控制流</h3><p>在一些函数中，我们可能需要在return语句之前做一些清理工作，比如释放在函数开始处由malloc申请的内存空间，使用goto总是一种简单的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));    </span><br><span class="line">    *p = <span class="number">10</span>;     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG    </span></span><br><span class="line">    <span class="type">int</span> error=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(error)        </span><br><span class="line">        <span class="keyword">goto</span> END;    <span class="comment">// dosomething</span></span><br><span class="line">END:    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;free&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，这个时候我们可以使用do{…}while(0)来做同样的事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ff</span><span class="params">()</span> </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));    </span><br><span class="line">    *p = <span class="number">10</span>;     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">do</span>&#123; </span><br><span class="line">        <span class="meta">#<span class="keyword">ifndef</span> DEBUG        </span></span><br><span class="line">        <span class="type">int</span> error=<span class="number">1</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>        </span></span><br><span class="line">        <span class="keyword">if</span>(error)            </span><br><span class="line">        <span class="keyword">break</span>;        <span class="comment">//dosomething  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;free&quot;</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将函数主体部分使用do{…}while(0)包含起来，使用break来代替goto，后续的清理工作在while之后，现在既能达到同样的效果，而且代码的可读性、可维护性都要比上面的goto代码好的多了。</p><h3 id="2-3-避免由宏引起的警告"><a href="#2-3-避免由宏引起的警告" class="headerlink" title="2.3 避免由宏引起的警告"></a>2.3 避免由宏引起的警告</h3><p>内核中由于不同架构的限制，很多时候会用到空宏，。在编译的时候，这些空宏会给出warning，为了避免这样的warning，我们可以使用do{…}while(0)来定义空宏：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#define</span> EMPTYMICRO <span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-定义单一的函数块来完成复杂的操作"><a href="#2-4-定义单一的函数块来完成复杂的操作" class="headerlink" title="2.4 定义单一的函数块来完成复杂的操作"></a>2.4 <strong>定义单一的函数块来完成复杂的操作</strong></h3><p>如果你有一个复杂的函数，变量很多，而且你不想要增加新的函数，可以使用do{…}while(0)，将你的代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。 这种情况应该是指一个变量多处使用（但每处的意义还不同），我们可以在每个do-while中缩小作用域，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fc</span><span class="params">()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> k1 = <span class="number">10</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;k1&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">do</span>&#123;        </span><br><span class="line">        <span class="type">int</span> k1 = <span class="number">100</span>;        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;k1&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;k1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Kqnonrime</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://kqnonrime.github.io/posts/9323.html" title="C++ Basics">https://kqnonrime.github.io/posts/9323.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"># -C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/17056.html" rel="prev" title="FMCW Radar"><i class="fa fa-chevron-left"></i> FMCW Radar</a></div><div class="post-nav-item"><a href="/posts/7474.html" rel="next" title="STM32入门">STM32入门 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#const"><span class="nav-number">1.</span> <span class="nav-text">const</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-const%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.const作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-const%E5%AF%B9%E8%B1%A1%E9%BB%98%E8%AE%A4%E4%B8%BA%E6%96%87%E4%BB%B6%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.</span> <span class="nav-text">2.const对象默认为文件局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">3.定义常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%8C%87%E9%92%88%E4%B8%8Econst"><span class="nav-number">1.4.</span> <span class="nav-text">4.指针与const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8const"><span class="nav-number">1.5.</span> <span class="nav-text">5.函数中使用const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8const"><span class="nav-number">1.6.</span> <span class="nav-text">6.类中使用const</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static"><span class="nav-number">2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">3.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#inline"><span class="nav-number">4.</span> <span class="nav-text">inline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof"><span class="nav-number">5.</span> <span class="nav-text">sizeof</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8E%9F%E5%88%991"><span class="nav-number">5.1.</span> <span class="nav-text">1.原则1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8E%9F%E5%88%992"><span class="nav-number">5.2.</span> <span class="nav-text">2.原则2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8E%9F%E5%88%993"><span class="nav-number">5.3.</span> <span class="nav-text">3.原则3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8E%9F%E5%88%994%E4%B8%8E5"><span class="nav-number">5.4.</span> <span class="nav-text">4.原则4与5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%8E%9F%E5%88%996"><span class="nav-number">5.5.</span> <span class="nav-text">5.原则6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">纯虚函数和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">1.纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">2.实现抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%87%8D%E8%A6%81%E7%82%B9"><span class="nav-number">6.3.</span> <span class="nav-text">3.重要点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84vptr%E4%B8%8Evtable"><span class="nav-number">7.</span> <span class="nav-text">C++虚函数的vptr与vtable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#virtual"><span class="nav-number">8.</span> <span class="nav-text">virtual</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">9.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E5%BA%94%E7%94%A8"><span class="nav-number">9.1.</span> <span class="nav-text">volatile应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E4%BD%BF%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text">volatile使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assert"><span class="nav-number">10.</span> <span class="nav-text">assert</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-field"><span class="nav-number">11.</span> <span class="nav-text">Bit field</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F%E4%BD%BF%E7%94%A8"><span class="nav-number">11.1.</span> <span class="nav-text">位域使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AF%B9%E9%BD%90"><span class="nav-number">11.2.</span> <span class="nav-text">位域的大小和对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">11.2.1.</span> <span class="nav-text">位域的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%AF%B9%E9%BD%90"><span class="nav-number">11.2.2.</span> <span class="nav-text">位域的对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BD%8D%E7%9A%84%E9%87%8D%E6%98%A0%E5%B0%84"><span class="nav-number">11.3.</span> <span class="nav-text">位域的初始化和位的重映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">11.3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E9%87%8D%E6%98%A0%E5%B0%84-Re-mapping"><span class="nav-number">11.3.2.</span> <span class="nav-text">位域的重映射 (Re-mapping)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E9%87%8D%E6%98%A0%E5%B0%84%E5%B0%86%E4%BD%8D%E5%9F%9F%E5%BD%92%E9%9B%B6"><span class="nav-number">11.3.2.1.</span> <span class="nav-text">利用重映射将位域归零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%81%94%E5%90%88-union-%E5%B0%86-32-Bits-%E4%BD%8D%E5%9F%9F-%E9%87%8D%E6%98%A0%E5%B0%84%E8%87%B3-unsigned-int-%E5%9E%8B"><span class="nav-number">11.3.2.2.</span> <span class="nav-text">利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="nav-number">12.</span> <span class="nav-text">extern “C”</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C-%E4%B8%8EC%E7%BC%96%E8%AF%91%E5%8C%BA%E5%88%AB"><span class="nav-number">12.1.</span> <span class="nav-text">1.C++与C编译区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C-%E8%B0%83%E7%94%A8C%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.</span> <span class="nav-text">2.C++调用C函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-C%E4%B8%AD%E8%B0%83%E7%94%A8C-%E5%87%BD%E6%95%B0"><span class="nav-number">12.3.</span> <span class="nav-text">3.C中调用C++函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%92%8CC-%E4%B8%ADstruct"><span class="nav-number">13.</span> <span class="nav-text">C和C++中struct</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C%E4%B8%ADstruct"><span class="nav-number">13.1.</span> <span class="nav-text">1.C中struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C-%E4%B8%ADstruct"><span class="nav-number">13.2.</span> <span class="nav-text">2.C++中struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-number">13.3.</span> <span class="nav-text">3.总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E5%92%8CC-%E4%B8%AD%E7%9A%84Struct%E5%8C%BA%E5%88%AB"><span class="nav-number">13.3.1.</span> <span class="nav-text">C和C++中的Struct区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UNION"><span class="nav-number">14.</span> <span class="nav-text">UNION</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E5%AE%9E%E7%8E%B0C-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="nav-number">15.</span> <span class="nav-text">C实现C++的面向对象特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#explicit-%E6%98%BE%E5%BC%8F-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">16.</span> <span class="nav-text">explicit(显式)关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">17.</span> <span class="nav-text">友元函数与友元类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E6%A6%82%E8%BF%B0"><span class="nav-number">17.1.</span> <span class="nav-text">0.概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">17.2.</span> <span class="nav-text">1.友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">17.3.</span> <span class="nav-text">2.友元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B3%A8%E6%84%8F"><span class="nav-number">17.4.</span> <span class="nav-text">3.注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#using"><span class="nav-number">18.</span> <span class="nav-text">using</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">18.1.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-number">18.2.</span> <span class="nav-text">改变访问性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">18.3.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E4%BB%A3typedef"><span class="nav-number">18.4.</span> <span class="nav-text">取代typedef</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">19.</span> <span class="nav-text">:: 范围解析运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#enum"><span class="nav-number">20.</span> <span class="nav-text">enum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E8%A1%8C%E4%B8%BA"><span class="nav-number">20.1.</span> <span class="nav-text">传统行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%81%9A%E6%B3%95"><span class="nav-number">20.2.</span> <span class="nav-text">经典做法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">20.3.</span> <span class="nav-text">C++11 的枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">20.4.</span> <span class="nav-text">类中的枚举类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype"><span class="nav-number">21.</span> <span class="nav-text">decltype</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">21.1.</span> <span class="nav-text">1.基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%8E%A8%E5%AF%BC%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">21.1.1.</span> <span class="nav-text">1.1 推导出表达式类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%B8%8Eusing-x2F-typedef%E5%90%88%E7%94%A8%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="nav-number">21.1.2.</span> <span class="nav-text">1.2 与using&#x2F;typedef合用，用于定义类型。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%87%8D%E7%94%A8%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">21.1.3.</span> <span class="nav-text">1.3 重用匿名类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%BB%93%E5%90%88auto%EF%BC%8C%E7%94%A8%E4%BA%8E%E8%BF%BD%E8%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">21.1.4.</span> <span class="nav-text">1.4 泛型编程中结合auto，用于追踪函数的返回值类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%A4%E5%88%AB%E8%A7%84%E5%88%99"><span class="nav-number">21.2.</span> <span class="nav-text">2.判别规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">22.</span> <span class="nav-text">引用与指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">22.1.</span> <span class="nav-text">1.引用与指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BC%95%E7%94%A8"><span class="nav-number">22.2.</span> <span class="nav-text">2.引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">22.2.0.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">22.2.0.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="nav-number">22.2.0.3.</span> <span class="nav-text">引用折叠</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%B7%AE%E8%B7%9D"><span class="nav-number">22.3.</span> <span class="nav-text">3.指针与引用的性能差距</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93-1"><span class="nav-number">22.4.</span> <span class="nav-text">3.总结</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">23.</span> <span class="nav-text">宏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%8F%E4%B8%AD%E5%8C%85%E5%90%AB%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="nav-number">23.1.</span> <span class="nav-text">1.宏中包含特殊符号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%96%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="nav-number">23.1.1.</span> <span class="nav-text">1.1 字符串化操作符（#）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%AC%A6%E5%8F%B7%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="nav-number">23.1.2.</span> <span class="nav-text">1.2 符号连接操作符（##）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BB%AD%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="nav-number">23.1.3.</span> <span class="nav-text">1.3 续行操作符（\）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-do-%E2%80%A6-while-0-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">23.2.</span> <span class="nav-text">2.do{…}while(0)的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%81%BF%E5%85%8D%E8%AF%AD%E4%B9%89%E6%9B%B2%E8%A7%A3"><span class="nav-number">23.2.1.</span> <span class="nav-text">2.1 避免语义曲解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8goto%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">23.2.2.</span> <span class="nav-text">2.2避免使用goto控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%81%BF%E5%85%8D%E7%94%B1%E5%AE%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="nav-number">23.2.3.</span> <span class="nav-text">2.3 避免由宏引起的警告</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%AE%9A%E4%B9%89%E5%8D%95%E4%B8%80%E7%9A%84%E5%87%BD%E6%95%B0%E5%9D%97%E6%9D%A5%E5%AE%8C%E6%88%90%E5%A4%8D%E6%9D%82%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">23.2.4.</span> <span class="nav-text">2.4 定义单一的函数块来完成复杂的操作</span></a></li></ol></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Kqnonrime" src="/images/wx.jpg"><p class="site-author-name" itemprop="name">Kqnonrime</p><div class="site-description" itemprop="description">轻推门扉，至见花影</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Kqnonrime" src="/images/wx.jpg"><p class="site-author-name" itemprop="name">Kqnonrime</p><div class="site-description" itemprop="description">轻推门扉，至见花影</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas" style="width:100%"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">-C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radar/" rel="tag">-Radar</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Radar-Antenna/" rel="tag">-Radar Antenna</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32F103/" rel="tag">-STM32F103</a><span class="tag-list-count">1</span></li></ul></canvas></div></div><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; Tue Sep 27 2022 08:00:00 GMT+0800 (中国标准时间) – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Kqnonrime</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共29.5k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hibiki.model.json"},display:{position:"right",width:150,height:350},mobile:{show:!1},log:!1})</script></body></html>